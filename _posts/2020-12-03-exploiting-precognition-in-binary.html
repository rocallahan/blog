---
layout: "post"
title: "Exploiting Precognition In Binary Instrumentation Of rr Replays"
date: "2020-12-02 11:44:00 +0000"
categories: "rr Pernosco"
permalink: "/2020/12/exploiting-precognition-in-binary.html"
---
<p>This post is part of a series about the <a href="/2020/12/rr-remix-efficient-replay-only-binary.html">rr remix</a> instrumentation engine that powers the <a href="https://pernos.co/about/overview">Pernosco omniscient debugger</a>.
<p>When <a href="https://rr-project.org">rr</a> replays a recording, it constructs processes that have identical memory and register contents to the recorded processes. It replays execution of the threads in those processes in steps; each step runs CPU code until some specific program state is reached (e.g., the next system call, or until registers and the retired-conditional-branch counter match some recorded values). The most efficient way to implement binary instrumentation of this code is to inject the instrumentation engine into each replay process so the engine and its generated code share the same address space as the application code and data. Then, instead of rr replay using <tt>PTRACE_CONT</tt> to directly execute application code, it uses <tt>PTRACE_CONT</tt> to enter the instrumentation engine, which is then responsible for executing the application code with instrumentation. When the engine detects that the instrumented code has reached the desired stopping point for that replay step, it returns control to rr replay.
<p>A key invariant is that <em>the remix engine produces the same effects as native execution on application memory and registers at the end of each replay step</em>. This ensures that rr replay continues to produce memory and register states that match those during recording. It also means we can switch between instrumented execution and native execution at any time between replay steps, e.g. we can replay up to a certain point using regular rr replay and then turn on instrumentation. This is useful for debugging the instrumentation engine and for applying instrumentation-based analysis to a subinterval of an rr recording. In particular Pernosco uses this to parallelize analysis by running multiple replays at once, each one instrumenting a different time interval in the recording.
<p>When injecting the instrumentation engine into each replay process we need to allocate a contiguous range of virtual memory that will never be used by the application. Fortunately, because this is an rr replay, <strong>we can see into the future</strong>. We can quickly scan the recording, identify a sufficiently large range of memory that will <em>never</em> be used in <em>any</em> replay process, and place the engine and its data there in all replay processes from the beginning.
<p>rr replay needs to count the number of retired conditional branches so that we can deliver asynchronous interrupts at the right time during program execution. Effectively, the RCB counter is part of the state that we instruct the engine to stop at. To avoid having to stop and start a hardware performance counter around the instrumentation's own conditional branches, the engine disregards hardware counters and instead adds instructions to count the conditional branches explicitly.
<h2>Single-Exit Fragments</h2>
<p>Like other instrumentation engines, remix processes a group of instructions at a time, translating each group of application instructions into instrumented instructions in a hidden code buffer; we call these groups "fragments". This lets us apply optimizations across instruction boundaries within a fragment. For example, the shortest instruction to increment our conditional branch counter is a single <tt>inc</tt> instruction, but this instruction modifies the CPU's arithmetic flags, which could disrupt the application. However, it is safe to modify flags if we can guarantee that the <tt>inc</tt> will always be followed by an application instruction that overwrites those flags without reading them. Conditional branches are often preceded by such instructions. Therefore, for example, consider the following application instructions:
<pre>    cmp r12,[rsp-8]
    jz <em>label</em></pre>
Because <tt>cmp</tt> overwrites the arithmetic flags, we can translate this code to
<pre>    inc [remix_rcb_counter]
    cmp r12,[rsp-8]
    jz <em>translated_label</em></pre>
<p>Correctly applying this kind of optimization in a binary instrumentation engine is more difficult than it looks, because of unexpected early exits from fragments. In this case, a problem would arise if <tt>rsp-8</tt> is not a valid address so that instruction triggers a segmentation fault. We would fault after incrementing <tt>remix_rcb_counter</tt>, counting a conditional branch that may never happen. Even worse, we will have corrupted the application flag values; the <tt>cmp</tt> instruction we were counting on to cover that up has not executed, and may never execute! (Keep in mind that segfaults don't have to be fatal...) Normally, the possibility of these unexpected exits limits the optimizations an engine can use, and/or requires elaborate recovery machinery to mitigate &mdash; machinery that adds overhead to the just-in-time binary instrumentation process.
<p>During remix execution, however, rr replay indicates whether execution will stop at a segmentation fault or not. If it will stop at a fault, the fault state will be the goal state for that execution step, and remix will insert code before the faulting instruction to stop execution when the right state has been reached &mdash; it will never execute a faulting instruction. In remix there are no early exits from fragments; once a fragment has been entered, it is guaranteed to run to completion. We can apply code motion within a fragment at will as long as dataflow dependencies are respected. <strong>Binary instrumentation of rr replays is a much easier problem than regular just-in-time binary instrumentation</strong> and this lets remix achieve lower overhead with a simpler implementation.