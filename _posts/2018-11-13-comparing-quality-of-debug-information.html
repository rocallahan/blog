---
layout: "post"
title: "Comparing The Quality Of Debug Information Produced By Clang And Gcc"
date: "2018-11-13 10:40:00 +0000"
categories: "rr Mozilla"
permalink: "/2018/11/comparing-quality-of-debug-information.html"
---
<p>I've had an intuition that clang produces generally worse debuginfo than gcc for optimized C++ code. It seems that clang builds have more variables "optimized out" &mdash; i.e. when stopped inside a function where a variable is in scope, the compiler's generated debuginfo does not describe the value of the variable. This makes debuggers less effective, so I've attempted some qualitative analysis of the issue.
<p>I chose to measure, for each parameter and local variable, the range of instruction bytes within its function over which the debuginfo can produce a value for this variable, and also the range of instruction bytes over which the debuginfo says the variable is in scope (i.e. the number of instruction bytes in the enclosing lexical block or function). I add those up over all variables, and compute the ratio of variable-defined-bytes to variable-in-scope-bytes. The higher this "definition coverage" ratio, the better.
<p>This metric has some weaknesses. DWARF debuginfo doesn't give us accurate scopes for local variables; the defined-bytes for a variable defined halfway through its lexical scope will be about half of its in-scope-bytes, even if the debuginfo is perfect, so the ideal ratio is less than 1 (and unfortunately we can't compute it). In debug builds, and sometimes in optimized builds, compilers may give a single definition for the variable value that applies to the entire scope; this improves our metric even though the results are arguably worse. Sometimes compilers produce debuginfo that is simply incorrect; our metric doesn't account for that. Not all variables and functions are equally interesting for debugging, but this metric weighs them all equally. The metric assumes that the points of interest for a debugger are equally distributed over instruction bytes. On the other hand, the metric is relatively simple. It focuses on what we care about. It depends only on the debuginfo, not on the generated code or actual program executions. It's robust to constant scaling of code size. We can calculate the metric for any function or variable, which makes it easy to drill down into the results and lets us rank all functions by the quality of their debuginfo. We can compare the quality of debuginfo between different builds of the same binary at function granularity. The metric is sensitive to optimization decisions such as inlining; that's OK.
<p>I built a <a href="https://github.com/rocallahan/debuginfo-quality">debuginfo-quality tool</a> in Rust to calculate this metric for an arbitrary ELF binary containing DWARF debuginfo. I applied it to the main Firefox binary <tt>libxul.so</tt> built with clang 8 (8.0.0-svn346538-1~exp1+0~20181109191347.1890~1.gbp6afd8e) and gcc 8 (8.2.1 20181105 (Red Hat 8.2.1-5)) using the default Mozilla build settings plus <tt>ac_add_options --enable-debug</tt>; for both compilers that sets the most relevant options to <tt>-g -Os -fno-omit-frame-pointer</tt>. I ignored the Rust compilation units in libxul since they use LLVM in both builds.
<p><img src="/assets/images/DefinitionCoverageRatio.png" width="763" height="470" title="clang 57%, gcc 76%">
<p>In our somewhat arbitrary metric, gcc is significantly ahead of clang for both parameters and local variables. "Parameters" includes the parameters of inlined functions. As mentioned above, the ideal ratio for local variables is actually less than 1, which explains at least part of the difference between parameters and local variables here.
<p>gcc uses some debuginfo features that clang doesn't know about yet. An important one is <tt>DW_OP_GNU_entry_value</tt> (standardized as <tt>DW_OP_entry_value</tt> in DWARF 5). This defines a variable (usually a parameter) in terms of an expression <em>to be evaluated at the moment the function was entered</em>. A traditional debugger can often evaluate such expressions after entering the function, by inspecting the caller's stack frame; our Pernosco debugger has easy access to all program states, so such expressions are no problem at all. I evaluated the impact of <tt>DW_OP_GNU_entry_value</tt> and the related <tt>DW_OP_GNU_parameter_ref</tt> by configuring <a href="https://github.com/rocallahan/debuginfo-quality">debuginfo-quality</a> to treat definitions using those features as missing. (I'm assuming that gcc only uses those features when a variable value is not otherwise available.)
<p><img src="/assets/images/DefinitionGNUExtensions.png" width="763" height="470" title="parameters 86% to 72% without DW_OP_GNU_entry_value">
<p><tt>DW_OP_GNU_entry_value</tt> has a big impact on parameters but almost no impact on local variables. It accounts for the majority, but not all, of gcc's advantage over clang for parameters. <tt>DW_OP_GNU_parameter_ref</tt> has almost no impact at all. However, in most cases where <tt>DW_OP_GNU_entry_value</tt> would be useful, users can work around its absence by manually inspecting earlier stack frames, especially when time-travel is available. Therefore implementing <tt>DW_OP_GNU_entry_value</tt> may not be as high a priority as these numbers would suggest.
<p>Improving the local variable numbers may be more useful. I used <a href="https://github.com/rocallahan/debuginfo-quality">debuginfo-quality</a> to compare two binaries (clang-built and gcc-built), computing, for each function, the difference in the function's definition coverage ratios, looking only at local variables and sorting functions according to that difference:
<pre style="white-space:pre-wrap">debuginfo-quality --language cpp --functions --only-locals ~/tmp/clang-8-libxul.so ~/tmp/gcc-8-libxul.so</pre>
This gives us a list of functions starting with those where clang is generating the worst local variable information compared to gcc (and ending with the reverse). There are a lot of functions where clang failed to generate any variable definitions at all while gcc managed to generate definitions covering the whole function. I wonder if anyone is interested in looking at these functions and figuring out what needs to be fixed in clang.
<p>Designing and implementing this kind of analysis is error-prone. I've made my analysis tool source code available, so feel free to point out any improvements that could be made.
<p><strong>Update</strong> Helpful people on Twitter pointed me to some excellent other work in this area. <a href="https://lists.llvm.org/pipermail/llvm-dev/2018-August/125780.html">Dexter</a> is another tool for measuring debuginfo quality; it's much more thorough than my tool, but less scalable and depends on a particular program execution. I think it complements my work nicely. It has led to <a href="https://bugs.llvm.org/show_bug.cgi?id=38768">ongoing work</a> to improve LLVM debuginfo. There is also <a href="https://gramanas.github.io/llvm-devlog/posts/finding-debuginfo-loss/">CheckDebugify</a> infrastructure in LLVM to detect loss of debuginfo, which is also <a href="https://bugs.llvm.org/show_bug.cgi?id=37953">driving improvements</a>. Alexandre Oliva has <a href="http://www.fsfla.org/~lxoliva/writeups/gOlogy/gOlogy.txt">an excellent writeup</a> of what gcc does to preserve debuginfo through optimization passes.
<p><strong>Update #2</strong> Turns out <a href="https://github.com/llvm-mirror/llvm/blob/master/tools/llvm-dwarfdump/Statistics.cpp">llvm-dwarfdump</a> has a --statistics option which measures something very similar to what I'm measuring. One difference is that if a variable has any definitions at all, llvm-dwarfdump treats the program point where it's first defined as the start of its scope. That's an assumption I didn't want to make. There is <a href="http://lnt.llvm.org/db_default/v4/nts/graph?plot.0=1357.1607042.4&highlight_run=115194">a graph</a> of this metric over the last 5.5 years of clang, using clang 3.4 as a benchmark. It shows that things got really bad a couple of years ago but have since been improving.
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>Stephen Kell</div>
<div class='content'>Very nice work. I have quite a lot of interest in debug info quality, so am hoping to come back and try this.

Have you seen the work from Sony (specifically SN Systems) on this topic? It includes another nice tool. https://github.com/SNSystems/dexter</div>
<div class='comment'>
<div class='author'>Robert</div>
<div class='content'>I have not. This is very cool.</div>
</div>
</div>
<div class='comment'>
<div class='author'>Brad Spencer</div>
<div class='content'>What about with -ggdb3?

https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html</div>
</div>

</div>