---
layout: "post"
title: "Abstraction Penalties, Stack Allocation And Ownership Types"
date: "2007-10-23 16:19:00 +0000"
categories: "Mozilla"
permalink: "/2007/10/abstraction-penalties-stack-allocation_23.html"
---
<div class="columns"><p>Sometimes, cleaning up your code makes it slower even when it shouldn't. For example, you might extract code from a function and make it a separate function. Maybe the compiler should inline your code, but it doesn't, or it does but the result still isn't the same as the original single function. This is an <em>abstraction penalty</em>: you use the programming language to structure your code with additional abstractions, and you pay a performance penalty.<br/><p>Grouping variables into structs or objects is a common source of abstraction penalties. For example, converting local variables <tt>nscoord x, y;</tt> to <tt>nsPoint pt;</tt> may prevent the coordinates from being placed in registers, in some compilers. Or the coordinates may need to be placed in memory if you pass an nsPoint to another function instead of two nscoords.<br/><p>That aside, there's a much worse abstraction penalty associated with objects in common "safe" languages such as Java or C#: they require heap allocation and garbage collection. (I'm ignoring C# structs for now for reasons that will hopefully become obvious.) And despite what people will tell you, garbage collection is still slower than stack allocation, often by a lot. When I was doing serious Java programming a few years ago, the way to make Java code fast was still to avoid using objects or manually recycle them to avoid allocation and GC costs. And the problem is that a whole lot of language features are tied up with objects --- interfaces, casting, information hiding, code reuse. I suspect one of the biggest performance issues switching from C++ to Java or C# may be that in C++ you can stack-allocate objects, but in Java and C# you can't. Just look at all the places where Gecko uses nsAutoString or nsAutoTArray to good effect.<br/><p>The problem is of course that in a safe language, you can't just hand out pointers to stack-allocated objects like candy, because someone might store one away in a dark place and then later, long after the method has returned, start using it as a dangling pointer. This cannot be allowed.<br/><p>What the world needs is a type system that allows references to stack objects to be given out, but restricts their usage so that no-one can use them after the objects are destroyed. Fortunately many such systems exist. A whole family of "region calculi" have been developed, for example. However, I prefer "ownership types" as a more intuitive and generally useful framework; in particular I like <a href="http://www.pmg.lcs.mit.edu/~chandra/publications/phd.pdf">Boyapati</a>-style "explicitly parametric ownership types".<br/><p>These work by adding an "ownership parameter" to each class type. These parameters are a lot like generic type parameters, but they denote the "owner" of the object. The basic rule is that an object cannot outlive its owner. This rule is enforced by the typechecker. Here's an example of how this can work:<br/><pre>class Vector&lt;O@P&gt; {<br/>(O@P[])@this array;<br/>int size;<br/>Vector() { array = new (O@P[100])@this; }<br/>void add(O@P o) { array[size++] = o; }<br/>};<br/>class Iterator&lt;O@P, Q&gt; where Q &lt;= P {<br/>Vector&lt;O@P&gt;@Q inner;<br/>int i;<br/>Iterator(Vector&lt;O@P&gt;@Q inner) { this.inner = inner; }<br/>O@P next() { return inner.array[i++]; }<br/>};<br/>void f() {<br/>C@method c1 = new C@method(), c2 = new C@method();<br/>C@method c3 = g(c1, c2);<br/>}<br/>C@R g&lt;R>(C@R c1, C@R c2) {<br/>Vector@method v = new Vector@method&lt;C@R&gt;();<br/>v.add(c1);<br/>v.add(c2);<br/>h&lt;R&gt;(v);<br/>return new C@R();<br/>}<br/>void h&lt;R,S&gt;(Vector&lt;C@R&gt;@S v) where S &lt;= R {<br/>Iterator@method iter = new Iterator@method&lt;C@R, S&gt;(v);<br/>while (C@R c = iter.next()) { ... }<br/>}</pre><br/>This code creates two objects, puts them into a standard growable vector class, then passes the vector to another function which uses a standard iterator to iterate over the vector. What's cool is that the compiler knows a lot about the lifetimes of these objects. In particular the objects which are <tt>@method</tt>, i.e., owned by "the current method", cannot outlive the method --- even though we pass these objects to other methods and even store references to them in other objects.<br/><p>These properties are enforced in two ways. The main constraint is that code can only refer to objects whose owners are in scope. For example, you cannot declare <tt>C@R glob;</tt> and set <tt>glob = c1;</tt> in <tt>g</tt> to "leak" a reference to <tt>c1</tt> --- the correct <tt>R</tt> is not in scope at the global level.<br/><p>Similarly, an object like <tt>Vector</tt> that takes ownership parameters can only take parameters that "outlive" the object itself. This guarantees that fields of the object cannot become dangling references. In some cases, such as <tt>Iterator</tt>, we need to add "outlives" constraints to its ownership parameters; <tt>Q &lt;= P</tt> would be read "P outlives Q". The semantics of ownership mean that "P outlives method" for all in-scope ownership parameters P.<br/><p>Given the code above, the compiler could, using only local reasoning,<br/><ul><br/><li>Stack allocate <tt>c1</tt>, <tt>c2</tt>, <tt>v</tt> and <tt>iter</tt><br/><li>Allocate space for <tt>g</tt>'s result in <tt>f</tt>'s stack<br/><li>Inline the <tt>array</tt> object directly into <tt>Vector</tt> --- the compiler knows that the <tt>array</tt> object cannot outlive its <tt>Vector</tt>, and because there is only one assignment, it cannot die before <tt>Vector</tt> either.<br/></ul><br/>Therefore the above code requires no heap allocations at all. ("Inlining" objects into their containing objects is another important optimization, much like stack allocation, that common safe OO languages do not support.)<br/><p>It's important to note that although a really good compiler could discover these optimizations in Java, for example, using escape analysis, there are major problems leaving it up to the compiler. The primary problem is that escape analysis is expensive and fragile and compilers don't do it very well. A secondary problem is that if you change your program so that escape analysis no longer works, the only way to tell is that your performance gets mysteriously worse. With explicit type constraints, you get a compile error instead. That's especially useful here because quite often when you create objects in a method you expect them to be method-local, and it would be great for the compiler to check that for you and give you an error if you're wrong (instead of generating code that's slow in Java or crashy in C++).<br/><p>Another note is that although the annotation burden appears large, the code can be slimmed down considerably using sensible default ownership parameters and other shortcuts such as local type inference:<br/><pre>class Vector&lt;O&gt; { // O contains @P<br/>O[] array; // fields default to @this<br/>int size;<br/>Vector() { array = new O[100]@this; }<br/>void add(O o) { array[size++] = o; }<br/>};<br/>class Iterator&lt;O, Q&gt; where Q &lt;= O@ {<br/>Vector&lt;O&gt;@Q inner;<br/>int i;<br/>Iterator(Vector&lt;O&gt;@Q inner) { this.inner = inner; }<br/>O next() { return inner.array[i++]; }<br/>};<br/>void f() {<br/>// local objects default to @method<br/>var c1 = new C(), c2 = new C();<br/>var c3 = g(c1, c2);<br/>}<br/>C@R g(C@R c1, C@R c2) {<br/>Vector v = new Vector&lt;C@R&gt;();<br/>v.add(c1);<br/>v.add(c2);<br/>h(v);<br/>return new C@R();<br/>}<br/>// implicit type and ownership parameters<br/>void h(Vector v) {<br/>var iter = new Iterator(v); // infer type parameters<br/>while (var c = iter.next()) { ... }<br/>}</pre><br/><p>There are even more tricks we can pull! For example, we know a @method object can't be accessed by other threads, so we can easily remove locking from it. In a transactional memory system we would know not to log accesses to it. When a method containing a @method object returns, we know the object must die, so we can deterministically run a destructor at that point, giving us the handy C++ pattern of using destructors for general cleanup on method exit. And when an object is about to go out of scope, we can often easily prove that the method's reference to the object is the only outstanding reference ("uniqueness"). In that case we are allowed to safely <em>change</em> the owner of the object to something else (which is never normally allowed)! This may require copying, depending on what optimizations have been performed. For example:<br/><pre>C@R f&lt;R&gt;() {<br/>var c1 = new C@method(), c2 = new C@method();<br/>var c = ... ? c1 : c2;<br/>// may copy the object from our stack to elsewhere<br/>return (C@R)c;<br/>}</pre><br/><p>Tragically, this stuff doesn't really exist yet in a usable language, nor has anyone proven it to work programming at large scales. Sigh...</div><br/><br/>
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>Noel Grandin</div>
<div class='content'>Another approach that I&#39;m playing with (for safety reasons, not for performance) in Java is to annotate fields and method parameters with escape info e.g.<br>public void xxx(@TakesRef char [] p);<br>public void yyy(@DoesNotTakeRef char [] p);<br>public class Class1 {<br>private final int [] bigBuffer;<br>@MayNotStoreRef<br>public int [] getBuffer() {<br>return bigBuffer;<br>}<br>}<br>and then use a checker to verify that data structures do not &quot;leak&quot;.<br></div>
</div>
<div class='comment'>
<div class='author'>Brian</div>
<div class='content'>Robert,<br>I&#39;m not an expert in this area, but I think your approach makes the burden on the programmer is indeed too large.<br>Its true that sometimes this ownership/region/escape information would be very helpful for the compiler, and in some of those cases the specific code is performance-critical. But it&#39;s only in the intersection of those two cases when you&#39;d want to go to the trouble of specifying all the additional detailed information.<br>I think a much better workflow would be something along the lines of:<br>1) write plain code without any of this extra info<br>2) run the compiler<br>3) the compiler will prompt with a list of places where it believes this extra info would be most helpful.<br>This would be even more useful if used with a profiling compiler (e.g. Hotspot in Java):<br>1) write plain code without any of this extra info<br>2) comile and run<br>3) the profiler will prompt with a list of places where it believes this extra info would be most helpful based on the actual profiled usage of the code.<br>Just my $0.02.<br></div>
</div>
<div class='comment'>
<div class='author'>Jason</div>
<div class='content'>The second half of this article is about stack allocation in Java:<br>http://www-128.ibm.com/developerworks/java/library/j-jtp09275.html<br>&quot;Escape analysis&quot; basically means inferring &quot;@method&quot; lifetime, right?  If you could infer it, why wouldn&#39;t you?  (I don&#39;t think having the compiler check my intuition about objects being method-local is worth it.)<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Jason: I answered this in my post. The truth is that escape analysis is expensive and fragile, and the escape analyses implemented by real VMs is weak. And then when it fails, your program slows down and it&#39;s impossible to tell what&#39;s going on.<br></div>
</div>
<div class='comment'>
<div class='author'>Kefer</div>
<div class='content'>re: Tragically, this stuff doesn&#39;t really exist yet in a usable language, nor has anyone proven it to work programming at large scales.<br>While I agree with you on this particular example, if we take &quot;stuff&quot; to mean the whole space of static-analysis tools we find that (1) it is eminently usable, and (2) it is extensively used.<br>E.g. Grammatech, Coverity, MS static tools, etc.<br>Your particular example may very well be solved next.<br>p.s. I&#39;m not affiliated with any of the companies.<br></div>
</div>
<div class='comment'>
<div class='author'>Jonathan Allen</div>
<div class='content'>This seems to be a solution looking for a problem. Memory allocation on stack-based heap like C# is just as cheap as allocating it on the local stack. The cost of deallocating can be highly variable, but if you are using short-lived objects, required for this &#39;solution&#39;, it is likewise cheap.<br>Meanwhile you are adding a huge amount of complexity to the language and compiler, complexity that may elminate the meager performance gains you are looking for.<br>And you never did expalin the problem with C# value types.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Jonathan: it&#39;s just *not* *true* that heap allocation is as cheap as stack allocation. People, notably Andrew Appel, and legions of followers have been pushing that line for years but they are wrong in practice. There are lots of reasons for this. For example, the analysis in the original Appel paper actually says that heap allocation is faster than stack allocation if you&#39;re willing to make the heap 7 or 8 times larger than the live objects. In real life no-one will do that.<br>But the real data point is that you ask people who are optimizing real Java programs whether they see a big win when they manually recycle objects instead of letting the GC handle everything, even on state-of-the-art JVMs --- and they do.<br>And then there are the object inlining optimizations, which no amount of intelligent GC can replicate.<br>&gt; Meanwhile you are adding a huge amount of<br>&gt; complexity to the language and compiler<br>I&#39;m adding some complexity to the language, but I&#39;m actually reducing the complexity of an optimizing compiler, because I don&#39;t need it to do any global static analysis.<br>C# value types can&#39;t be used to do the example I gave. For one thing, you can&#39;t store references to them in other objects --- only copies.<br>Kefer: static analysis is a very very large field, containing many things that are very practical and many things that are completely impractical...<br></div>
</div>
<div class='comment'>
<div class='author'>Edouard</div>
<div class='content'>I&#39;m looking forward to comparing Apples with Apples when we get quality implementations of C++0x&#39;s GC in a range of compilers.<br>The two things I feel that C++ really has over other languages (acknowledging there are many places it falls behind) is stack based object lifetime management (which gives us things like RAII, and, as you say, certain allocation and deallocation efficiencies) and an advanced template system, that other static languages don&#39;t come close to. I think C++ gets a bad rap sometimes, which is unfair because it does do some things very well.<br>As for GC - I once read a wise person who said &quot;The problem isn&#39;t garbage collection, the problem is garbage creation&quot;, which makes sense I think - he was talking specifically about speeding up production Smalltalk code, and that culling unnecessary object creation was usually all that was needed. I imagine that is just as true in Java as well many other GC-capable systems.<br></div>
</div>
<div class='comment'>
<div class='author'>Greg</div>
<div class='content'>Cyclone (cyclone.thelanguage.org) has an alternative slant on all of this based on region calculi.  The notational overhead is quite a bit lower than what you sketched here.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Hi Greg!<br>Someone should study the comparison of regions with ownership types. There are obviously huge similarities, but also interesting differences. One interesting difference is that ownership types can give you a hierarchy (because one object can own others). Another interesting difference is that ownership types can be used for other things ... in fact, I think I&#39;m the only person pushing ownership types for memory management.<br></div>
</div>
<div class='comment'>
<div class='author'>Reinier Zwitserloot</div>
<div class='content'>Your assumptions are all wrong. Also, you don&#39;t need annotations for this - compilers can actually infer almost all of it.<br>Fortunately, that&#39;s what java will be doing. It already infers &#39;escape detection&#39; (the idea that a certain object is never ever released into any code outside the method scope), starting in java 1.6. From java 1.7 and up, escape detection will be used to stack-declare objects. Java 1.6 already uses escape detection, amongst other things, to eliminate void locks (locks on objects that don&#39;t escape are useless locks).<br>However, this isn&#39;t nearly as much of a speed up as you seem to suggest. You should read up on &#39;eden&#39; garbage collection systems.<br>This is basically how it works:<br>95%+ of all objects live for VERY short periods of time, unless you use outdated and these days BACKWARDS rules such as &#39;create a pool of objects and re-use them&#39;. Please don&#39;t do that. Use immutables instead, java can aggressively inline those. The &#39;eden&#39; system has one heap page (which should be in cache almost all the time) where ALL new objects are created. Everytime eden is full, each object in eden that is *STILL* accessible from some place is copied over to the real heap. This is maybe only 5% or so of all objects there. Then, the pointer into eden is reset to 0 and the process starts all over again. The heap page itself is never malloced or freed - it&#39;s always in use by java and rewritten over and over.<br>End result: Most objects you just create as a helper live their entire lifetime in cached pages. This is just as good as a stack variable, really.<br>I don&#39;t get why escape detection is &#39;expensive&#39;. It&#39;s a purely compile-time construct; once the compiler is done, that&#39;s it. No time is spent during runtime to figure out if things escape. The compiler itself realizes a certain object is never ever stored in any place that outlives its method.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Reinier: you clearly haven&#39;t read what I wrote. And why don&#39;t you use the term &quot;copying collector&quot; like the rest of the world?<br></div>
</div>

</div>