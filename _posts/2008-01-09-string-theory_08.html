---
layout: "post"
title: "String Theory"
date: "2008-01-08 11:33:00 +0000"
categories: "Mozilla"
permalink: "/2008/01/string-theory_08.html"
---
<div class="columns"><p>Strings are perhaps the most important data type. They're probably the second most used after fixed-width integers, but they consume far more memory. Measurements of large Java apps such as Eclipse and Websphere would often show 30% or more of the live heap being consumed by strings. Not only are strings important, there are also many degrees of freedom for designing string representations and APIs, and you see large projects making a variety of choices, even though the impact of those choices is not widely understood. I believe strings are hugely understudied and there's a lot of interesting PhD-level research that could be done on strings. Tragically, strings (like email and parsing) are considered "old hat" and unlikely to attract top-class research attention. Anyway, let me jot down a few thoughts that have been festering for a long time...<br/><p><strong>UTF-16 is the devil's work</strong>. Once upon a time the Unicode consortium promised that 16 bits would be enough space for all the characters of the world's languages. Everyone believed it and, since 16 bits is not too much more than the 8 bits people were already using for Latin text, everyone designed their "Unicode" APIs to work with 16-bit characters, because that was simpler than variable-width representations. Later, though, the consortium realized they'd made a wee mistake, 16 bits wasn't going to be enough. No-one wanted to change all their APIs and using 32 bits per character is a hefty penalty for Latin text so everyone redefined their 16-bit units to mean "UTF-16 code units", i.e., some characters are represented with two code units ("surrogate pairs"). The problem is, UTF-16 thus has basically the same complexity as a good variable-width format such as UTF-8, but uses double the memory of UTF-8 for Latin text.<br/><p><strong>No-one really needs <tt>charAt</tt></strong>. One of the major touted advantages of a uniform character size is that it makes charAt(index) trivially efficient. However, almost all the code I've ever seen that indexes into strings is actually <em>iterating</em> through strings (or using APIs that return indexes into strings, which could just as easily use iterators). Implementing efficient bidirectional iterators for UTF-8 is trivial. You only really need fast charAt for <em>random access</em> into strings, and the only code I know of that needs it is <a href="http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm">Boyer-Moore string search</a> --- but that can be easily implemented efficiently for UTF-8 just by searching over UTF-8 code units instead of Unicode characters.<br/><p><strong>UTF-8 rules</strong>. UTF-16 is nearly as complex as UTF-8. UTF-16 is actually worse to code for because surrogate pairs are extremely rare, much rarer than multibyte UTF-8 characters, so you get code paths that are not well tested or code where surrogate pairs are not handled at all. For Latin text UTF-8 uses only half the space (note that even with non-Latin languages, programs still manipulate lots of Latin text internally), and you have the excellent property that ASCII text is valid UTF-8. In performance-critical code (such as our DOM implementation) you often see optimizations that switch between UTF-16 or "UCS-1" (text that's all characters 0-255, 8 bits per character), with code duplication for the "8-bit path" and the "UTF-16 path". With UTF-8 none of this is necessary, which is really good --- code duplication is evil, it requires new families of string types, forces programmers to make choices about string representations, and requires conversions that are potentially costly in code and time. UTF-8 is also easier to migrate to from ASCII, you just keep your 8-bit characters and redefine their meaning. The great irony is that platforms that implemented Unicode support late, such as the Linux kernel and glib/GTK+, saw all this and correctly chose UTF-8, while the early Unicode adopters (and those who must interoperate with them) are saddled with UTF-16 baggage.<br/><p><strong>charAt isn't going away</strong>. Tragically a lot of APIs, including JS APIs required for Web compatibility, rely heavily on charAt (although fortunately regexps are getting used more and more). Because it's actually indexing a UTF-16 buffer, charAt has the horrible specification "returns the n'th code unit in the UTF-16 representation of the string", and of course most code doesn't even bother trying to handle surrogate pairs correctly. Nevertheless, we're stuck with it, so we need an efficient implementation of UTF-16 charAt over a UTF-8 representation. The most obvious approach is some simple index caching: cache the results of charAt operations in (string, UTF-16 index, UTF-8 index) triples (e.g. by storing a UTF-16 index and a UTF-8 index in each string, or using a hash table). The charAt implementation can then look up the cache; "near matches" in the UTF-16 index in either direction can be used to derive the new charAt result. For simple code that's just incrementing or decrementing the index, this will work pretty well. (You'll need a little bit of hacking to handle cases when the UTF-16 index is in the middle of a surrogate pair, but it doesn't look hard.)<br/><p>You could make that work even better with some compiler wizardry. You want to identify integer variables that are being used as UTF-16 indices, and associate with each such variable a "shadow" UTF-8 index for each string that the variable indexes. These are a lot like regular loop induction variables. Then you add code to keep these variables in sync and use the UTF-8 indices for the actual string operations. If you do a good job you could get rid of the UTF-16 indices entirely in many cases. This approach extends to other APIs like "find" too.<br/><p>There are a lot more choices to make in a string API beyond just the character representation. For example:<br/><ul><br/><li>Should strings be mutable or immutable?<br/><li>Should mutable strings be append-only or randomly mutable? (I don't see a need for random-access mutation although many APIs support it)<br/><li>Should strings be able to share buffers (for fast substring operations)?<br/><li>Should strings be able to span multiple buffers (for fast concatentation)?<br/><li>Should you intern strings (i.e., force strings with the same contents to share a single buffer)? If so, when and how?<br/><li>How should string buffer memory be managed?<br/><li>How should thread safety be handled?<br/><li>Should string buffers be null terminated, or have an explicit length field, or both?<br/></ul><br/><p>I don't have strong opinions on those questions, although I think it would be very interesting to try just having a single string type that was UTF-8, mutable but append-only, no buffer sharing, spanning, or interning, compile-time (i.e. template) configurable with a certain number of characters directly in the string (nsAutoString style), falling back to the heap, no built-in thread safety, null terminated with an explicit length in bytes. Such a string would probably use a (length, buffer size, buffer pointer, 0-or-more-auto-bytes) format, and it would be fun to try optimizing the auto-buffer case by using the buffer size and buffer pointer memory as character data.<br/><p>Experiments I'd like to see:<br/><ul><br/><li>What percentage of memory is used by strings in Gecko (or whatever your favourite program is)?<br/><li>How much of that memory is UTF-16 code units with a high zero byte?<br/><li>How much memory would be saved (or wasted) if we used UTF-8?<br/><li>What statistical patterns are there in API usage? Is there a clear need for different string types that optimize for different patterns?<br/><li>Measure the code, time and space impacts of varying the above decisions!<br/></ul><br/>The "memory" measurements should probably be memory-time products. For Gecko, you'd want to look at a variety of workloads, e.g., including a CJK-heavy page set.<br/><p><strong>Update</strong> I've updated the post to use the term "code units" where I had incorrectly mentioned "code points". Also, I want to mention that most strings manipulated by Gecko are small and so constant factors matter: simplicity of implementation is important for performance and for programmer understanding. The ability to stack-allocate small strings is also important.</div><br/><br/>
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>Kenneth Waters</div>
<div class='content'>After spending a lot of time looking at various ways to represent strings, I&#39;m a big fan of ropes for a non-interned string representation.  Ropes are immutable, have O(1) substring and concatination, and are thread-safe.  They tend to fragment memory and work best with GC though.<br>Interned strings are odd, I think X11 does a great job with interned strings, but that seems like a niche use.  Someone should see how much contention there is on the mutexs around Java&#39;s string interning table in a big multi-threaded app.  How often are you really comparing strings or using them as dictionary keys?  I suppose you could just store a hash of the string in it&#39;s representation, that would get you fast hashing and comparing (although not as fast as interning).<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>There have been studies of schemes that intern strings during GC. You can use a good concurrent hash table to get around the threading issues. Not a bad idea but interning in general requires an immutable string API, and I&#39;m not sure that&#39;s the way to go.<br>Ropes are pretty heavyweight. In Gecko, most of the time we&#39;re working with short strings and I fear ropes are not very efficient for that (although I&#39;d like to see some experiments). Constant factors matter.<br></div>
</div>
<div class='comment'>
<div class='author'>Darin Fisher</div>
<div class='content'>Isn&#39;t UTF-16 a more compact representation for many scripts?  CJK in particular.<br></div>
</div>
<div class='comment'>
<div class='author'>Marko Macek</div>
<div class='content'>I like:<br>- immutable<br>- non-zero terminated<br>- shared/refcount (fast substring/split/iteration)<br>- UTF-8<br>- a separate append-only StringBuffer for incremental creation<br>I&#39;m not sure if thread safety is needed.<br>This is a very nice model for C++ code, but I&#39;m not sure if it&#39;s useful for higher layer code (javascript).<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Darin: yeah, but look at the source for a Chinese Web page (e.g. mingpao.com). There&#39;s far more ASCII than Chinese (often mixed in the same DOM nodes, even). And even for the CJK characters, we&#39;re only talking about 3 bytes per character instead of 2. We should measure it but I doubt there&#39;s a big win for UTF-16.<br>Marko: it turns out that using the same representation for Javascript as for C++ would provide a nice speedup for DOM API calls.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>PS Darin, you should write a retrospective on the design and evolution of XPCOM strings :-).<br></div>
</div>
<div class='comment'>
<div class='author'>Neil</div>
<div class='content'>Would it be worthwhile having a ASCII/UTF-8 flag bit on your string so that you can do fast CharAt, ToLowerCase etc. on ASCII strings? (As I recall ToLowerCase is slow on UTF-8, as you have to convert K to k for instance.)<br></div>
</div>
<div class='comment'>
<div class='author'>Deewiant</div>
<div class='content'>Isn&#39;t a &quot;code point&quot; always the same, regardless of encoding? E.g. U+10000 &quot;LINEAR B SYLLABLE B008 A&quot;: its code point is 10000. Its representation in UTF-16 is composed of two code *units*, 0xd800 and 0xdc00. Likewise its UTF-8 representation has four code units, 0xf0 0x90 0x80 0x80.<br>If the specification of charAt really refers to &quot;code points&quot; then that onerous hackery with UTF-16 indexing isn&#39;t necessary and you can just find the code point normally from the UTF-8 representation.<br>If, however, it refers to code units, then it&#39;s as bad as you say.<br>And lastly, if it refers to something as ambiguous as a &quot;character&quot; you can do whatever you wish. But I suppose you knew this already. ;-)<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Deewlant: sorry, everywhere I said &quot;code point&quot; I meant &quot;code unit&quot;. I&#39;ll fix that.<br>Neil: that might be useful, but it has the unfortunate effect that code that&#39;s O(N) on ASCII text could become O(N^2) as soon as a non-ASCII character is tested. That&#39;s a bit too surprising for the programmer for my taste. Not sure what the problem is with ToLowerCase in UTF-8, it&#39;s linear time at least and you could easily implement an approach that&#39;s in-place for ASCII text (just scan along doing ToLowerCase in place, and when you find the first non-ASCII character you start a copying approach at that point).<br></div>
</div>
<div class='comment'>
<div class='author'>Boris</div>
<div class='content'>roc, what are your thoughts re: interning on the setup Gecko actually uses on the C++ side?  That is, the ability to intern strings as needed (nsIAtom)?<br>I admit that it kinda sucks that certain APIs require the use of interned strings while others require non-interned ones, and that interning often includes charset conversions.  In some ways it would be very nice if our interned strings were simply a subclass of nsString or some such, with an overridden operator== and possibly lazy internment as needed or something.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>The value of automatic interning is highly workload dependent --- my research on &quot;Object Equality Profiling&quot; showed that, although it&#39;s obvious anyway. The first incarnation of .NET did aggressive automatic interning but Microsoft backed off in later versions.<br>But yes, it would be super if manual interning gave you a regular string or something compatible with a regular string. That should be easy, just have nsAtom contain an nsString and offer a method returning a const nsString&amp;. If our strings were UTF-8 then this would work great.<br></div>
</div>
<div class='comment'>
<div class='author'>Leon Mergen</div>
<div class='content'>In my opinion, thread safety should be up to the programmer who uses the string class. Like you already stated, strings are used a LOT in programs, and thread safety is not an issue in a lot of cases -- a lot of unnecessary overhead would take places where it will not be used, and in the places that it *does* get used, other locking mechanisms will probably have to be used anyway.<br>Other than that, i *really* like the idea of shared buffers between strings, for fast copy, substring and concat. Memory can be saved, and the heap is used less often. Anyone is aware of existing implementations of that yet ?<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>I agree that thread safety should not be part of a string API.<br>Shared buffers add complexity, especially when you go to strings that can span multiple buffers (for efficient concatenation). We used to support buffer-spanning strings in Gecko but Darin took them out, for a significant perf win. I would really like to see data that shows whether/when buffer sharing is worthwhile. GC and refcounting environments let you share strings trivially, and C++ const references let you share strings a lot too, so I&#39;m not sure that the added benefit of buffer sharing (for fast substring, mostly) is worth it.<br></div>
</div>
<div class='comment'>
<div class='author'>DAH</div>
<div class='content'>If strings can share buffers, then they have to provide thread-safety also: What happens when two different string variables, sharing the same buffer, are modified concurrently? User code can’t know that they share the same buffer and need to be locked.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>That&#39;s true and is a good argument against buffer sharing, IMHO. Unless you make strings immutable as Java and .NET do.<br></div>
</div>
<div class='comment'>
<div class='author'>Mark</div>
<div class='content'>&quot;Christian&quot;?<br>We really didn&#39;t need to know that.<br></div>
</div>
<div class='comment'>
<div class='author'>Marko Macek</div>
<div class='content'>Here&#39;s an implementation that&#39;s useful if you like doing lot&#39;s of substring/split/parsing:<br>It doesn&#39;t do cheap concat, but as said above, it&#39;s often not an optimization. It does cheap substring and split.<br>http://icewm.cvs.sourceforge.net/icewm/icewm-1.2/src/mstring.h?revision=1.7.2.2&amp;view=markup<br>http://icewm.cvs.sourceforge.net/icewm/icewm-1.2/src/mstring.cc?revision=1.7.2.2&amp;view=markup<br>It&#39;s a ref-counted buffer, used by the string struct that handles substrings, ... Some performance optimization of refcounting is probably needed (for iteration, mostly).<br>It&#39;s not currently UTF-8/unicode oriented (uses plain bytes), but that could be fixed.<br>The strings are immutable (Since javascript has immutable strings, I see no downside to this).<br>It&#39;s probably sensible to always do a &#39;copy&#39; when you have a substring and are assigning a new value to a class member (as opposed to stack assignment/passing, I wish c++ had a way to differentiate this).<br>The &#39;cstring&#39; class is used for passing strings to C functions and uses a trick: while the base string class is not guaranteed to be zero terminated it actually does always allocate one byte extra for &#39;0&#39;, removing the need to do a &#39;copy&#39; + append &#39;0&#39; in most cases (for safety, you would probably need to check if there&#39;s an early zero-terminator).<br>For threading there are two issues:<br>- atomic reference counting (easily added, but costs performance).<br>- atomic assignment is not possible, since this is a struct (this may or may not be a problem).<br>For mutable strings, there should be a separate class that has nothing shared (but potentially allows the string class to steal it&#39;s buffer without copying).<br>Well, that&#39;s my take on string theory.<br></div>
</div>
<div class='comment'>
<div class='author'>Jerome</div>
<div class='content'>&quot;the only code I know of that needs it is Boyer-Moore string search --- but that can be easily implemented efficiently for UTF-8 just by searching over UTF-8 code units instead of Unicode characters&quot;<br>Hmm... Isn&#39;t the whole point of boyer-moore is to not scan, say, characters 0 to 17 when checking the 18th is sufficient? Scanning bytes to check for utf-8 multi-byte units seems to be as expensive as checking bytes for equalness, whose avoidance was the specific purpose of boyer-moore.<br></div>
</div>
<div class='comment'>
<div class='author'>Gryph0n</div>
<div class='content'>@Mark<br>Why is it that Christian offends you, but Kiwi doesn&#39;t? Thats part of his identity and to him Christian is as important as Kiwi or hacker<br>Go create a blog with &quot;Atheist&quot; or whatever you identify with. Don&#39;t bug others because you don&#39;t like what they identity with.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Jerome: what I&#39;m suggesting is that you convert the search string and the searched string to UTF-8 and then run Boyer-Moore over those bytes. It should work reasonably well because if the input Unicode characters are fairly random the UTF-8 bytes are also reasonably well-distributed. (It wouldn&#39;t work if UTF-8 used, say, 0xFF a lot to indicate something special.)<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Hmm, but I guess if you use a lot of characters from the same small Unicode range (pretty common), you&#39;ll get a single prefix byte that will occur very frequently and stuff up Boyer-Moore.<br>On the other hand though, if you did implement Boyer-Moore for Unicode characters, you&#39;d need to build some huge tables. So I don&#39;t think Boyer-Moore really works well for Unicode no matter how you do it.<br></div>
</div>
<div class='comment'>
<div class='author'>Jason</div>
<div class='content'>Aside from charAt(), code units are exposed via the .length property, charCodeAt(), indexOf()/lastIndexOf(), slice()/substring(), RegExp.lastIndex, and the .index property of arrays returned by RegExp.exec().<br>Also, in ECMAScript Edition 4, it is proposed that strings will be indexable, sort of like in Python:<br>&quot;hello world&quot;[6] == &quot;w&quot;<br>Of course all these methods can use the same cache of string offsets.<br>But no matter what you do here, all this stuff will be slower than an implementation that just uses UTF-16.  Just not O(N) slower.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>&gt; Also, in ECMAScript Edition 4, it is proposed<br>&gt; that strings will be indexable, sort of like in<br>&gt; Python:<br>&gt;<br>&gt; &quot;hello world&quot;[6] == &quot;w&quot;<br>That&#39;s evil! That basically forces implementations to use UCS-4 if you decree that JS characters are Unicode characters, or UTF-16 if you decree that they&#39;re UTF-16 code units. (The latter case is really bad though because it would let people create invalid surrogate pairs or else give you weird error cases to check and handle.) I really strongly encourage you to revisit that decision.<br>&gt; But no matter what you do here, all this stuff<br>&gt; will be slower than an implementation that just<br>&gt; uses UTF-16. Just not O(N) slower.<br>Not necessarily. For ASCII text UTF-8 is more compact and therefore a performance win.<br></div>
</div>
<div class='comment'>
<div class='author'>Somebody</div>
<div class='content'>Newspaper-style text columns on webpages are the devil&#39;s work. And three or more is just taking the piss...<br></div>
</div>
<div class='comment'>
<div class='author'>Jason Orendorff</div>
<div class='content'>&gt; That&#39;s evil!<br>Maybe, but the cat was already out of the bag.  ECMAScript Edition 3 explicitly allows you to create invalid surrogate pairs.  &#39;(\ud800)&#39;, for example, is allowed.  ES3 strings are unrestricted sequences of 16-bit values, by spec.  I&#39;m pretty sure Edition 4 will not change this.<br>Anyway, you can encode unpaired surrogates in UTF-8, if you don&#39;t mind having total garbage in your strings.<br>&gt; For ASCII text UTF-8 is more compact and therefore a performance win.<br>Right, plus you probably convert less.  By &quot;all this stuff&quot; I just meant the operations mentioned--the ones that are a fast array lookup in UTF-16 and a hash table lookup plus in UTF-8.<br></div>
</div>
<div class='comment'>
<div class='author'>Joshua Cranmer</div>
<div class='content'>Some points about strings from my experience with Java.<br>Java, I feel, has the best string implementation of major languages. Much of this is probably due to it having one string type and not several (char *, wchar_t *, string, wstring), although some people have complained about this. I would like to point out that said complaints are most often in the context of Java cannot print out 100,000 lines of output as quickly as C, but I digress.<br>It is my opinion that strings should be immutable, like any other type of object whose primary usage lies in communication between different steps of the system while being retained in the state. However, an efficient builder should be provided (like Java&#39;s StringBuilder and not like StringBuffer--the builder should be optimized for speed and not thread-safety).<br>Random access is a bit of a thorny point. Coming from a Java background, I have a tendency to use code like the following:<br>int index = reference.indexOf(&quot;:&quot;);<br>String protocol = reference.substring(0,index);<br>String rest = reference.substring(index+1);<br>That sort of usage is one that API designers must expect people to use and abuse. I would think that caching the result of a lookup for a random access would improve performance, since most usages of a random-access would be immediately followed by an operation around said access point.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>That&#39;s not random access. Think about it: first you scan from the start of the string looking for a &quot;:&quot;. Then you make a substring from the start of the string up to the point you got to, and another substring from that point to the end. You could just as easily write<br>StringIterator index = reference.indexOf(&quot;:&quot;);<br>String protocol = reference.substring(0,index);<br>String rest = reference.substring(index.next());<br>This would work just fine with UTF8 and no caching, StringIterator just keeps its internal index in bytes.<br></div>
</div>
<div class='comment'>
<div class='author'>jmdesp</div>
<div class='content'>Encoding unpaired surrogates in UTF-8 probably deserves quite a few evilness point, but nonetheless is quite well described use pattern with a name &quot;CESU-8&quot; and a dedicated unicode technical report ;-)<br>http://www.unicode.org/unicode/reports/tr26/<br>The doctor&#39;s prescription is internal use only ;-)<br>It&#39;s certainly the best solution to keep API level UTF-16 compatibility without performance cost.<br></div>
</div>
<div class='comment'>
<div class='author'>Phil Endecott</div>
<div class='content'>Hi Robert,<br>Thanks for an interesting post, which happens to cover exactly the subjects that I have been worrying about recently. I&#39;m the author of Anyterm, which is a terminal on a web page; see the demos at http://anyterm.org/demos.html.  It has a C++ server that does terminal emulation, converts the screen to HTML, and then diffs new screens against old; the &quot;edit script&quot; from the diff is sent to the Javascript in the browser which &quot;patches&quot; the HTML terminal that it&#39;s showing.  There are lots of strings in there, and in the latest release I finally got around to making it work properly with different character sets (or so I thought).<br>So, first of all with my Javascript hat on, I&#39;m really horrified to learn that JS string indices are UTF-16 code units!  Ugh!  My code certainly doesn&#39;t get that right.  Is it really too late to go and fix that?  So Firefox will let me chop a string in two:<br>s1 = s.substr(0,n);  s2 = s.substr(n);<br>giving potentially invalid strings if the split was in the middle of a UTF-16 character, and then join them back together:<br>assert(s1+s2 == s);<br>and have what I started with???  And how many other browsers get that right???  I would guess that the amount of code that&#39;s broken in the face of that situation must be greater than the code that relies on it, so &quot;fixing&quot; the spec would probably make more sites work, not fewer.<br>With my C++ user&#39;s hat on:  partly because of this project, I decided to put together a &quot;string tagged with its character set&quot; class, and I&#39;ve discussed this on the Boost list.  In my proposal, a UTF-8 string would have three types of iterator:<br>- A mutable random-access iterator over units (i.e. bytes).<br>- A const bidirectional iterator over characters.<br>- A mutable output (&quot;append&quot;) iterator over characters.<br>This gives you everything that you can do with O(1) iterator de-referencing, and nothing that you can&#39;t.<br>You can read about this if you search the Boost list archive from last September and October, and look for my name.<br>Sorry this has got so long.  Thanks for the thought-provoking article.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>&gt; Is it really too late to go and fix that?<br>Yes. Indexing into strings is interpreted as UTF-16 code units, Web compatibility depends on it.<br>&gt; And how many other browsers get that right???<br>The major ones do, I guess.<br>Your proposal sounds good, except I&#39;d avoid having strings lying around with different character sets. Other character sets should be converted into UTF-8 as early as possible.<br></div>
</div>
<div class='comment'>
<div class='author'>skierpage</div>
<div class='content'>Returning to Neil&#39;s idea, would you not assume each string is UTF-8 to begin.  But if and when code determines a string is &quot;ASCII&quot;, e.g. to implement the functions Jason cites, then set the ASCII (more accurately, eachCodeUnitInHereIsOneByte?) flag.<br>I seem to recall there was a lot of cleanup of the strings in Gecko maybe around 1.7 (nsACString, nsAutoString, NS_NAMED_LITERAL, etc.) , but I can&#39;t find the informative posts from back then.  http://developer.mozilla.org/en/docs/XPCOM_string_guide is still hella complex.<br></div>
</div>
<div class='comment'>
<div class='author'>Edouard</div>
<div class='content'>Ahh, strings. My personal opinion is that there are only two representations that make any sense at all. UCS-4 and UTF-8.<br>UTF-16 is actually just what happened when everyone looked at the initial Unicode spec and thought that what is now the BMP was all anyone would even need. Then it turned out it wasn&#39;t, but all that software from the early to mid 90s was stuck with UCS-2, and so the move to UTF-16 (vs. a move to UCS-4) looked like the lesser of two evils. Plus if you had clients relying on your APIs, you were painted into a corner more still.<br>But if I look at the average amount of RAM that a computer had in 1991 (which is when Unicode 1.0 came out), it was 4M. I&#39;m sure some people suggested that 32-bit characters would be OK back then, but were shouted down by the (then legitimate) concern that we didn&#39;t have that kind of memory to burn. So UCS-2 was a pragmatic choice. But today? The machines I&#39;m ordering have 4G in them - three magnitudes larger. Is doubling the size of the basic character unit really a problem? I suspect it&#39;s just an vague feeling of wastefulness that has people still against it, whereas the reality is that UCS-4 would make a minimal impact on the vast majority of programs. And, as roc implies, UTF-16 is evil.<br>UTF-8 is an interesting direction as well. Well internally anyway - the world is, for the most part, now UTF-8 externally, and that is as it should be. But to base your app on UTF-8 strings? Definitely a rarer move, although I remember when Bram took Vim Unicode by moving the internal representations to UTF-8. It turns out that it&#39;s technically a fine decision. Most people will recoil from the idea, but I think their opinions are based on feeling rather than fact, much as with UCS-4.<br>None of this alleviates the issues you have to deal with with Unicode. Array indexing for actual characters in the face of combining diacriticals, and other wackiness, is not going to be made easy like it is for ASCII no matter what string format you choose. There&#39;s still an enormous amount of work that Unicode forces you to do, but at least you shouldn&#39;t have to put up with UTF-16 at the same time. Fast and slow paths is one way to go to remove the performance penalty in 99% of strings, but there are many other ways to address the low level issues.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>&gt; UTF-16 is actually just what happened when<br>&gt; everyone looked at the initial Unicode spec<br>You&#39;re restating what I wrote, right?<br>&gt; the reality is that UCS-4 would make a minimal<br>&gt; impact on the vast majority of programs<br>I don&#39;t agree. Like I said, measurement of large apps shows a very significant fraction of the live heap is strings. Doubling that would cause considerable pain.<br>&gt; Array indexing for actual characters in the<br>&gt; face of combining diacriticals<br>It turns out you never really have to do that, that is a corollary of my &quot;No-one really needs charAt&quot; paragraph.<br></div>
</div>
<div class='comment'>
<div class='author'>Edouard</div>
<div class='content'>&gt; You&#39;re restating what I wrote, right?<br>I like to think of it as &quot;agreeing with you&quot;.<br>Only with a bit of historical perspective to indicate that the initial UCS-2 decision was made at a time when memory was microscopic in comparison to today. 4M of RAM total in a 1991 machine. The Firefox 3 beta in front of me takes 10 times that or more just to start up today.<br>As Maximillian Cohen once said, &quot;11:15, restate my assumptions.&quot;<br></div>
</div>
<div class='comment'>
<div class='author'>nabraj</div>
<div class='content'>String s = &quot;nabraj&quot;;<br>is this initialization static or dynamic? how it works internally, because String is a class and we are just assigning literals to it.<br>would you please clarify this?<br></div>
</div>
<div class='comment'>
<div class='author'>Zack</div>
<div class='content'>I&#39;m just waiting for the day it becomes clear that sixteen planes is not enough.  UTF-8 and UCS-4 as originally specified wouldn&#39;t even blink, but we had to go break them for compatibility with UCS-2/UTF-16...<br></div>
</div>
<div class='comment'>
<div class='author'>Mark</div>
<div class='content'>Just reject adding extra characters.<br>After they did it with Klingon, I prefer using only ASCII<br>Summary of this thread:<br>UTF-8 is nice, but due to broken JavaScript API (and other) specs, UTF-16 (nee UCS2) is required for performance.<br>I do prefer immutable strings.<br></div>
</div>

</div>