---
layout: "post"
title: "The Glyph Bounds Problem"
date: "2007-05-24 21:58:00 +0000"
categories: "Mozilla"
permalink: "/2007/05/glyph-bounds-problem_24.html"
---
<div class="columns"><p>New textframe is looking pretty good. I'm dogfooding it and so are a few other people. The list of regressions is fairly short. We should be able to turn it on as soon as the tree opens for alpha6.<br/><p>In the meantime I'm thinking about the glyph bounds problem. This is the problem of certain characters in certain fonts having glyphs that are particularly large, and fall outside the "font box" for the glyph: i.e. the glyph extends above the font's specified ascent, below the font's specified descent, to the left of the glyph origin ("left bearing"), or to the right of the glyph advance ("right bearing"). When a text frame contains such glyphs, we need to carefully compute the "overflow area" --- the union of the extents of the (positioned) glyphs --- when we lay out the text. That lets us redraw the correct area efficiently if the text moves or changes. Since time immemorial we have assumed no glyphs overflow their font boxes, which is plain wrong and getting more wrong as fonts get fancier...<br/><p>The hard part (as often in the world of browser text) is performance. For example, the Mac implementation of cairo_glyph_extents gets the glyph extents by retrieving the glyph outline curves from ATS and computing their bounding boxes with grim mathematics. There's no way in the world we could apply that to each glyph, even with caching. The other Mac APIs aren't better, I'm told, and the other platforms aren't looking good performance-wise either.<br/><p>One possible approach is to exploit the fact that normally we only care about glyph bounds if they overflow the font box. If we could examine the font and determine cheaply for each glyph if it's guaranteed to not overflow the font box, we'd be fast on most fonts and pages, where these check will succeed and we won't need the exact bounds for the glyphs. Looking at the OpenType/TrueType font format, the 'glyf' table contains, for each glyph, min/max x and y coordinates for the glyph. But this data does not take hinting into account. Hinting could make the glyph larger than that box.<br/><p>Perhaps we can be a little conservative and assume that hinting will make the glyph at most ascend one more pixel, and descend one more pixel. We could also assume that hinting will not increase the left bearing and will not increase the glyph right bearing (because its hinted advance should increase if the glyph width does). Of course these are just heuristics, and it would be a good idea test them against a large collection of fonts to see if they hold. But if they hold, we should be able to use the 'glyf' data to quickly rule out overflow for a large number of glyphs.<br/><p>There is one more problem: when we actually compute the bounding box approximation for a string of glyphs, our glyph advances may include kerning. The font box definition above assumed no kerning. This probably won't worry us in practice because we generally measure substrings that end with spaces or have no characters following them, so there is no kerning across the end of the substring.<br/><p>Grabbing and analyzing these tables could still be expensive. I wish there was a better way, but I can't see one right now. Possibly the way to go, if it was practical, would be to abandon "overflow areas" in Gecko, but then we repaint a lot more than we have to when documents change dynamically.<br/><p>One remaining card we can play is to identify common fonts that have no overflowing glyphs and hardcode that knowledge into Gecko to avoid looking up tables. That would be ugly, but expedient.</div><br/><br/>
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>Eli Friedman</div>
<div class='content'>&quot;One remaining card we can play is to identify common fonts that have no overflowing glyphs and hardcode that knowledge into Gecko to avoid looking up tables.&quot;<br>Excluding the letter &quot;f&quot;?  That optimization won&#39;t get very far otherwise; almost every font in existence has an overflowing &quot;f&quot;.<br></div>
</div>
<div class='comment'>
<div class='author'>pagalmes</div>
<div class='content'>Do you know the following:<br>&quot;I just read about another interresting initiative that aims at &quot; providing a single place in the free desktop software stack to add support for new complex languages and provide consistent behavior across applications when it comes to text shaping.&quot;<br>http://labs.trolltech.com/blogs/2007/03/30/working-towards-a-unified-text-layout-engine-for-the-free-desktop-software-stack/<br></div>
</div>
<div class='comment'>
<div class='author'>Jim Grandy</div>
<div class='content'>hi roc,<br>(Long time no talk, by the way! Brendan Eich mentioned your blog and I&#39;ve been reading for a couple of week.)<br>Per glyph bounds calculations on the Mac, I presume there&#39;s a reason you can&#39;t use ATSUGlyphGetScreenMetrics in ATSUnicodeGlyphs.h? You can pass in a list of glyph IDs, and description of the style being used to render the glyphs, and get back the &quot;the specified glyphs&#39; advance and side bearings, top left, height, and width&quot;.<br>If you have an ATS layout object, there are also low-level APIs in ATSUnicodeDirectAccess.h that allow you to get into the low-level datastructures used to render each layout.<br>If these APIs aren&#39;t sufficient for you, drop me a line and I&#39;d be happy to help work through the details.<br></div>
</div>
<div class='comment'>
<div class='author'>Peter</div>
<div class='content'>So can we expect working soft hyphens in the nightlies after turning new textframe on? (sorry, I&#39;m not following development of the new textframe very well, but judging from the checked-in source code I&#39;d say yes ...)<br>Thank you<br></div>
</div>
<div class='comment'>
<div class='author'>Stuart Ballard</div>
<div class='content'>Possibly a stupid question: is it possible to tell when a glyph overflows it&#39;s box *at the time that text is laid out, or rendered or whatever*?<br>Presumably *some* piece of code must know that at that point, because some piece of code just drew the pixels that didn&#39;t lie within those boxes. But the question is whether that knowledge is available at a layer where you can make use of the information.<br>If so, you could keep a table at runtime of which fonts have ever overflowed their boxes in any string that has ever been rendered / laid out since the program was launched, updating that table if a font that previously had never overflowed suddenly does so. That way you don&#39;t need any ugly hardcoded knowledge, and while it&#39;s possible to have a font which might overflow that&#39;s not in the table, by definition that doesn&#39;t matter, because it hasn&#39;t overflowed on any string you&#39;ve ever seen yet...<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Eli:<br>&gt; almost every font in existence has an overflowing<br>&gt; &quot;f&quot;.<br>It does? I&#39;d be surprised, since then I think we&#39;d see bugs about f-related garbage in Gecko.<br>pagalmes: yes, I know about it. Since we&#39;re using Pango on Linux, we benefit from it. One day it might be interesting to consider using it directly.<br>Jim: Looong time no see. Thanks for the info. ATSUGlyphGetScreenMetrics didn&#39;t work when Brian Ewins tried to use it in cairo. I&#39;ll follow up in email, thanks! We are using the direct access APIs but you can&#39;t get glyph boudns that way.<br>Peter: yes, soft hyphens work with the new textframe.<br>Stuart: right, this information must exist at least by the time the glyph is drawn. But we need it at layout time and it would be nice to get it without having to rasterize every glyph, since typically we render fewer glyphs than we measure.<br>One complication with the scheme I presented in this blog post is that it can&#39;t handle situations where the font engine is manipulating the outlines in ways that could cause overflow. For example, italicization using a shear matrix. So maybe this scheme won&#39;t be very useful :-(.<br></div>
</div>
<div class='comment'>
<div class='author'>Eli Friedman</div>
<div class='content'>re: the letter f<br>I&#39;m sure there are at least a couple bugs; I can&#39;t find them at the moment.  There aren&#39;t many bugs filed because it&#39;s only a few pixels for normal font sizes and we normally invalidate more than the absolute minimum.<br>Simple testcase:<br>data:text/html,&lt;body style=&quot;font-family: sans-serif; font-size: 150px&quot;&gt;&lt;div style=&quot;overflow:hidden&quot;&gt;&lt;div style=&quot;overflow:hidden;float:left&quot;&gt;asdf&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;hide&quot; style=&quot;border: solid; width: 0px&quot;&gt;asdf&lt;/div&gt;&lt;div&gt;&lt;button onclick=&quot;document.getElementById(&#39;hide&#39;).style.visibility=&#39;hidden&#39;;&quot;&gt;hide div&lt;/button&gt;&lt;/div&gt;<br>On Windows at least, clicking the button leaves junk for many fonts; the problem is a lot worse for serif fonts. (Times New Roman leaves a garbage pixels even at 16px font-size; Arial doesn&#39;t start leaving garbage until a little under 30px.)  The problems get worse with italics.<br>Opacity makes things worse; it cuts off an additional pixel.<br></div>
</div>
<div class='comment'>
<div class='author'>Edouard</div>
<div class='content'>Are you sure you need to calculate tight bounding boxes initially? Surely that&#39;s a form of premature optimisation - when some text changes you then know it&#39;s worth calculating a more accurate bounding box (or boxes) at that point. If you don&#39;t use the higher quality information, why calculate it in the first place?<br>But perhaps I&#39;m misunderstanding the issue - your comment about needing the tighter bounding boxes for when text is moved or redrawn implies they high-quality metrics can be delayed until then to me, but then again, I&#39;ve got no real idea about how Gecko works...<br>(I was thinking about the technique of delaying any and all optimisations until they are actually needed from a couple of videos I&#39;ve just been watching about Smalltalk/Self and Java JIT engines, and how one of the most successful approaches has been to JIT nothing, but have a counter on everything - and only after a certain threshold is hit, JIT that fragment into a LRU code cache.)<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Eli: Well, that testcase works fine for me on Mac in FF2, but I&#39;ll take your word for it. We could still optimize by hardcoding knowledge like &quot;every glyph except &#39;f&#39; in the following fonts fits in the font box: ...&quot; And your argument is all the more reason we need to fix this glyph bounds problem once and for all.<br>Edouard: you&#39;re really asking whether glyph bounding boxes can be computed lazily. That&#39;s something I&#39;ve thought about. It might be possible but it might require significant changes to Gecko, changes that we don&#39;t have resources to make for Gecko 1.9.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>here&#39;s a problem with lazy glyph bounds: suppose we load a Web page, display it, and then something changes in the page (the caret blinks, an animated GIF changes, whatever). In the common case we then need to calculate the glyph extents of every single glyph on the page to see if it might be an insane-size glyph that just happens to extend over the element that changed. Not much laziness possible there...<br></div>
</div>
<div class='comment'>
<div class='author'>jmdesp</div>
<div class='content'>Is there now way to store the pre-calculated info to reuse it in future sessions ? (similar to fastload)<br>And/or it could be pre-calculated in a separate thread with characters actually required being put in front of the list.<br>Or you could hardcode that if there&#39;s not Zapf in the name it will never extend more than some reasonable value like 1 em ;-)<br></div>
</div>
<div class='comment'>
<div class='author'>Chris</div>
<div class='content'>https://bugzilla.mozilla.org/show_bug.cgi?id=331716<br>There is at least one bug for &quot;f&quot;s.<br></div>
</div>

</div>