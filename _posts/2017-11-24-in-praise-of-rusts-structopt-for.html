---
layout: "post"
title: "In Praise Of Rust's structopt For Command Line Parsing"
date: "2017-11-24 01:54:00 +0000"
permalink: "/2017/11/in-praise-of-rusts-structopt-for.html"
---
<p>I've built a lot of command-line tools over the years, mostly in C or C++, but also in Java, Python, Rust, Turbo Pascal, etc. I mostly rolled my own command-line parsing because I did not find <a href="http://man7.org/linux/man-pages/man3/getopt.3.html">getopt</a> very useful, and in most of those languages importing third-party libraries is more effort than reward for such a relatively simple task. In Rust I used the <a href="https://docs.rs/clap/2.27.1/clap/">clap</a> library because it provides more functionality (e.g. useful help text) at a lower cost (Rust makes managing library dependencies so easy). I recently discovered <a href="https://docs.rs/structopt-derive/0.1.5/structopt_derive/">structopt</a> and tried it out. Finally, the one true way to parse command-line options!
<p>With <tt>structopt</tt> you provide a Rust data structure defining a simple AST for your command-line options. You mark it up with structopt-specific attributes describing more details of the syntax, e.g. option names. Markup is minimized using sensible defaults and leveraging Rust conventions: doc-comments are used as help text, <tt>Option</tt> makes arguments optional, subcommands use <tt>enum</tt>s, value are parsed using the <tt>FromStr</tt> trait, etc. Then structopt generates code (using Rust's "custom derive") that parses the command line options into your data structure. It uses <tt>clap</tt> underneath so you get helpful error messages, support for generating shell completion scripts, etc. But unlike using <tt>clap</tt> directly, you get the final parsed results which you can use from Rust code in a completely natural way, e.g. using <tt>match</tt> on subcommand enums. It's beautiful. It also has practical advantages for maintenance: for example, unused arguments are unused fields and produce compiler warnings. Take a look at <a href="https://docs.rs/structopt-derive/0.1.5/structopt_derive/">the examples</a>.
<p>This is a special case of deserialization. A lot of programming is serializing and deserializing, and we have also used Rust's <a href="https://github.com/serde-rs/serde">serde</a> library <a href="http://robert.ocallahan.org/2017/07/lets-never-create-ad-hoc-text-format.html">to great effect</a>. There must be more opportunities to use Rust custom-derive to implement DSLs for specialized serialization and deserialization problems.