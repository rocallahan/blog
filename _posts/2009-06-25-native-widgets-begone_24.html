---
layout: "post"
title: "Native Widgets Begone"
date: "2009-06-24 18:12:00 +0000"
categories: "Mozilla"
permalink: "/2009/06/native-widgets-begone_24.html"
---
<div class="columns"><p>Recently I've been working removing the use of native widgets (Windows HWNDs, Cocoa NSViews, GdkWindows) in various places in Gecko. Native widgets get in the way of painting and event handling, and break things due to various platform limitations.<br/><p>The key difficulty of getting rid of native widgets is ensuring we still handle windowed-mode plugins adequately. For example, currently if a windowed-mode plugin is contained in an overflow:auto element we rely on a native widget associated with the element to scroll and clip the plugin. In situations where we should clip but there is no native widget present, like 'clip' on an absolutely positioned element, we actually don't currently clip the plugin, which is pretty bad.<br/><p>My new strategy for clipping plugins is to explicitly compute a clip region for each plugin and use native platform APIs to clip the plugin's widget to that region. On Windows we can use <a href="http://msdn.microsoft.com/en-us/library/aa930600.aspx ">SetWindowRgn</a>, on X we can use the XShape extension via <a href="http://developer.gimp.org/api/2.0/gdk/gdk-Windows.html">gdk_window_shape_combine_region</a>. On Mac we don't have to do either of these things, because plugins work a bit differently there. One issue of course is figuring out what the clip region should be. For that, I'm reusing our <a href="/2005/11/frame_display_lists.html"> display list machinery</a>. We build a display list for the region of the page that contains plugins, and then traverse the display list to locate each visible windowed-mode plugin --- its position, and what clipping is affecting it. Plugins that aren't in the display list aren't visible so we hide them. This works really well, and means that everywhere we clip Web content, plugins are automatically affected as well.<br/><p>A nice bonus is that display lists contain information about which elements are opaque. We already have the ability to determine that part of an element is covered by opaque content and thus doesn't need to be drawn. We can leverage this for plugins too: areas of a plugin we know are covered by opaque content (e.g. a DIV with a solid background color) are clipped out. This means that all the crazy hacks people have been using to get content to appear above a windowed-mode plugin today (e.g., positioned overflow:auto elements and IFRAMEs) will no longer be needed with Gecko; you can just position a DIV or table with a solid background color. The hacks still work of course, as long as the hacked element has a solid background. (Credit where it's due: IIRC clipping holes for opaque Web content out of windowed plugins was first suggested by a KHTML developer long ago.)<br/><p>This also fixes relative z-ordering of plugins with other plugins and Web content. We don't have to touch native widget z-ordering because windowed-mode plugins are opaque. So if plugin A is supposed to be drawn in front of plugin B, but its widget is behind plugin B's widget, then we effectively punch a hole in plugin B's widget so you can see plugin A through it. It sounds a little crazy but it works just fine.<br/><p>Perhaps the greatest challenge here for us is getting scrolling to work smoothly on all platforms. In general we may have an IFRAME or overflow:auto element in the page, which contains one or more plugins which need to move smoothly with the scrolled content. A naive implementation would just bitblit the Web content and then move and clip the plugin widgets, creating a variety of exciting and unwanted visual artifacts. I designed a new cross-platform scrolling API which is quite rich; you pass in the rectangle you want to scroll, the amount you want to scroll it, and a list of commands to reconfigure child widgets that should be performed with the scroll "as atomically as possible". These commands let the caller change the position, size and clip region of some or all child widgets. This gives the platform-specific code great freedom to reorder operations. I described some of the implementation issues on X in <a href="/2009/06/stupid_x_tricks.html">a previous post</a>.<br/><p>I think I've got things working pretty well. My patches pass tests on all platforms on the try servers. There are 24 patches in my patch queue, many of them small preparatory cleanup patches. The big important patches enable region-based plugin clipping, modify a ton of code to remove the assumption that every document has a native widget as its root, actually remove the native widgets associated with content IFRAMEs, and remove the native widgets used for scrolling and implement the new scrolling system.<br/><p>In order to not change too much at once, I've left some things undone. In particular "chrome documents" like the Firefox UI still use native widgets in quite a few places. There's a lot of followup simplifications that we can do, like eliminate the "MozDrawingArea" abstraction that we currently use to support guffaw scrolling. In fact, apart from fixing a ton of plugin and visual bugs, the main point of this work is to enable further changes.<br/><p>For people who are interested, I've got some <a href="https://build.mozilla.org/tryserver-builds/rocallahan@mozilla.com-try-f9bf8fa4178/">try-server builds</a> available for testing. I'm particularly interested in IME and accessibility testing, since although the code passes tests I suspect external IME and AT code may be making assumptions about our native widget hierarchy that I'm breaking. General scrolling and plugin performance is also worth looking at.</div><br/><br/>
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>RyanVM</div>
<div class='content'>I&#39;ll give the win32 build a shot tonight. Out of curiosity, would you expect this to help with scrolling performance in the fixed background case?<br></div>
</div>
<div class='comment'>
<div class='author'>RyanVM</div>
<div class='content'>I can reproduce sayrer&#39;s comments about GMail redrawing issues as well. That said, once again, scrolling is noticeably smoother when reading an email conversation (whereas before where multiple messages expanded in an email thread would slow scrolling down massively). Very encouraging!<br></div>
</div>
<div class='comment'>
<div class='author'>Rob Sayre</div>
<div class='content'>I tried the mac build. It mostly works, but there seem to be some invalidation problems. The most obvious ones I found were scrolling with a scrollwheel on gmail (the left side menus don&#39;t redraw well) and Google Analytics, where selecting date ranges doesn&#39;t update the calendar.<br></div>
</div>
<div class='comment'>
<div class='author'>David Bolter</div>
<div class='content'>So far so good (via MarcoZ) for accessibility.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>RyanVM: fixed backgrounds? Hmm, depends on the page. On some pages it might help, on others it&#39;s a pure gfx performance issue.<br></div>
</div>
<div class='comment'>
<div class='author'>RyanVM</div>
<div class='content'>FWIW, scrolling on a Twitter page with a fixed background feels noticeably less laggy with your tryserver build vs. 3.5RC2.<br></div>
</div>

</div>