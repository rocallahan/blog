---
layout: "post"
title: "Our Rectangles Overfloweth"
date: "2007-12-29 20:41:00 +0000"
categories: "Mozilla"
permalink: "/2007/12/our-rectangles-overfloweth_29.html"
---
<div class="columns"><p>When we're laying out content in Gecko, we create an nsIFrame object for each CSS box for each element, <a href="/2007/10/if_i_did_it.html">as I've described previously</a>. CSS actually defines <a href="http://www.w3.org/TR/REC-CSS2/box.html#box-dimensions">several kinds of boxes</a>: margin boxes, border boxes, padding boxes and content boxes, depending on exactly what part of each element is included. In nsIFrames we store border-boxes always, and can reconstruct margin, padding and content boxes on demand.<br/><p>CSS boxes for an element do not necessarily contain the boxes for that element's children. However, there are some situations where we want to aggregate geometry information for an entire subtree of elements:<br/><ul><br/><li>For "overflow:scroll/auto" elements we need to figure out how far we should permit scrolling in each direction. A reasonable thing to do here would be to compute, and possibly store, the smallest rectangle containing the border-boxes for all elements which have the scrollable element as a containing block ancestor. Note that for overflow:auto elements, we need to know this during layout because we need to decide whether scrollbars should be shown.<br/><li>To optimize repainting, we want to be able to quickly test whether a subtree of content is responsible for painting anything visible in a given rectangle that needs repainting. An obvious solution is to store on some or all elements a rectangle which contains all pixels drawn by the subtree rooted at the element.<br/></ul><br/><p>In Gecko we mash together both of these concepts into the single concept of an "overflow rect". Every nsIFrame has an "overflow rect" which is the smallest rect containing both every pixel drawn by the frame and its descendants, and also the border-boxes of the frame and its descendants. We do the obvious optimization of not storing the rect when it's equal to the frame's border-box --- usually true since overflow is still the uncommon case. Combining the two concepts simplifies code and reduces memory usage. It usually doesn't produce any noticeable effects, but there are some unfortunate and relatively rare situations where it does. For example, adding a CSS "outline" to the child of an overflow:auto element can result in a scrollbar being displayed just so you can scroll the edge of the outline into view.<br/><p>One unfortunate thing is that right now every container frame's Reflow method is responsible for computing the overflow area for the frame by unioning together the overflow areas of all child frames. It's only a few lines per Reflow method but like all code duplication it's unnecessary bloat and it's fragile too.<br/><p>Another unfortunate thing is that the "bounding box of drawn pixels" area can be expensive to compute, in particular because it means <a href="/2007/05/the_glyph_bound.html">you have to retrieve the ink extents for every glyph</a>.<br/><p>In a perfect world, I think we'd separate these two concepts, and store 0, 1 or 2 additional rectangles for each nsIFrame. We'd compute "scrollable overflow areas" by walking the frame tree directly from scrollframes instead of spraying code through Reflow() implementations. We'd compute the "drawing overflow area" lazily, possibly even while painting; this would get the expensive glyph extents operations off the layout path, which would speed up layout flushes, e.g. when script requests geometry data via <tt>getBoundingClientRect()</tt> or <tt>offsetTop</tt>.<br/><p>I've thought pretty hard about ways to avoid computing the "drawing overflow area" at all. It's certainly possible for content that remains hidden, such as a hidden IFRAME or background tab. Unfortunately for the common case of page loading you almost always load the page, render it, and then something changes on the page --- a caret blink, an animated GIF, incremental content load --- and that usually forces you to compute the "drawing overflow area" of most elements in the page, in case they overlap the area you need to repaint. For example we should get the extents of each glyph on the page, to see if there's an insanely large glyph that might overlap the repaint area. (As I've explained in other posts, currently, even on trunk, for performance reasons we fudge and assume that at small font sizes glyphs stay within their regular font boxes. Webkit does something similar.)</div><br/><br/>
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>Alfred Kayser</div>
<div class='content'>Some comments:<br>1. Don&#39;t forget about &#39;outline&#39;, which adds another box that can contain drawable pixels.<br>2. For animated images, if we apply the rule that the size of the first frame is the total size of the animated image, the actual size of the box of drawable doesn&#39;t change. (but for some frame only a part of it needs to be redrawn).<br></div>
</div>

</div>