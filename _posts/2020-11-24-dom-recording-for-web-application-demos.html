---
layout: "post"
title: "DOM Recording For Web Application Demos"
date: "2020-11-24 04:08:00 +0000"
categories: "Mozilla Pernosco"
permalink: "/2020/11/dom-recording-for-web-application-demos.html"
---
<p>To show off the power of our <a href="https://pernos.co/about/overview">Pernosco debugger</a>, we wanted many short demo videos of the application interface. Regular videos are relatively heavyweight and lossy; we wanted something more like <a href="https://asciinema.org">Asciinema</a>, but for our Web application, not just a terminal. So we created <a href="https://github.com/Pernosco/DOMRec">DOMRec</a>, a DOM recorder.
<p>The approach is surprisingly straightforward. To record a demo, we inject the DOMRec script into our application. DOMRec captures the current DOM state and uses a <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">DOM Mutation Observer</a> to record all DOM state changes with associated timestamps. To replay the demo, we create an <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe">iframe</a>, fill it with the recorded initial DOM state, then replay the DOM state changes over time. Replay inserts links to the original stylesheets but doesn't load or execute the original scripts. (Of course it couldn't be quite that simple ... see below.)
<link rel="stylesheet" href="https://static.pernos.co/content/1CTVKKU-PkZxpi3FpbNfOoxZS7Y7j-NwqxI0BlnOTdA.css">
<script src="https://static.pernos.co/content/dcb7cHVBOL-MN1Hx_PhMWXIf8CK-V0dW64oUxc40flI.js" defer></script>
<script src="https://static.pernos.co/content/5Z7P3Ng6Uwd1o_NexAi0C8nj-5zXBdeLP_z7ywe4Z84.js" async></script>
<div class="DOMRecMovie" id="sourceFileMovie" style="width:1400px; height:626px"></div>
<p>The resulting demos are compact (most of ours are less than 100KB gzipped), work on almost any browser/device, and are pixel-perfect at any zoom level. DOMRec supports single-frame screenshots when dynamism is not required. We can't use browser HTML5 video controls but we implement play/pause/fullscreen buttons.
<p>Capturing DOM state isn't quite enough because some rendering-relevant state isn't in the DOM. DOMRec logs mouse movement and click events and during replay, displays a fake mouse cursor and click effect. DOMRec tracks focus changes, and during replay sets "fake focus" classes on relevant DOM elements; our application style sheets check those classes in addition to the real <tt>:focus</tt> and <tt>:focus-within</tt> pseudoclasses. When necessary DOMRec creates a fake caret. DOMRec captures scroll offsets and makes a best-effort attempt to match scroll positions during recording and replay. <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas</a> drawing operations don't change the DOM and don't trigger events, so our application manually triggers a "didDrawCanvas" DOM event which DOMRec listens for. Sometimes the Pernosco client needs to trigger a style flush to get CSS transitions to work properly, which also needs to happen during replay, so we fire a special notification event for that too. It's  a bit ad-hoc &mdash; we implemented just enough for needs, and no more &mdash; but it does at least handle Microsoft's <a href="https://microsoft.github.io/monaco-editor/">Monaco editor</a> correctly, which is pretty complicated.
<p>DOMRec can record demos executed manually, but in practice our demos are scripted using Selenium so that we can rebuild the demo movie when our application interface has changed.
<p>This kind of thing has certainly been built many times &mdash; see <a href="https://inspectlet.com">Inspectlet</a> and its competitors &mdash; so when I first looked into this problem a few years ago I assumed I would find an open-source off-the-shelf solution. Unfortunately I couldn't find one that looked easy to consume. Now we're releasing <a href="https://github.com/Pernosco/DOMRec">DOMRec</a> with an MIT license. To tell the truth, we're not trying hard to make DOMRec easy to consume, either; as noted above, some applications need to be tweaked to work with it, and this blog post is about all you're going to get in terms of documentation. Still, it's only 1200 lines of standalone Javascript so people may find it easier than starting from scratch.