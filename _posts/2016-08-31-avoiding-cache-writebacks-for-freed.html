---
layout: "post"
title: "Avoiding Cache Writebacks For Freed Memory"
date: "2016-08-31 00:25:00 +0000"
permalink: "/2016/08/avoiding-cache-writebacks-for-freed.html"
---
<p>I wonder how much memory traffic is generated by the CPU writing out evicted cache lines for memory locations the application knows are dead because they belong to freed memory. This would be interesting to measure. If it's significant, then perhaps the application (or some lower level of the software stack) should be trying more aggressively to reuse freed memory, or perhaps it would be valuable to have hardware support for invalidating cache lines without writing them back. Though I suppose the latter case is problematic since it would make buggy software nondeterministic. At the OS level Linux has <tt>madvise(..., MADV_DONTNEED)</tt> to clear unwanted pages, but I'm not aware of anything analogous for the CPU cache.
<p><strong>Update</strong> Xi Yang pointed me at a paper on exactly this topic: <a href="http://users.cecs.anu.edu.au/~steveb/downloads/pdf/scrub-pact-2014.pdf">Cooperative Cache Scrubbing</a>.
<blockquote>For modern Java programs, 10 to 60% of DRAM writes are useless, because the data on these lines are dead - the program is guaranteed to never read them again.</blockquote>
That's a lot more than I expected! It would be very interesting to know what these numbers are for C++ or Rust programs. If the numbers hold up, it sounds like it would be worth adding some kind of hardware support to quash these writes. It would be nice to avoid the problem of nondeterministic behavior for buggy software; I wonder if you could have a "zero cache line" instruction that sets the cache line to zero at each level of cache, marks the lines as clean, and writes zeroes to RAM, all more efficiently than a set of non-temporal writes of zero. Actually you might want to be able to do this for a large range of virtual addresses all at once, since programs often free large chunks of memory.
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>Gerald</div>
<div class='content'>&quot;trying more aggressively to reuse freed memory&quot;
Quick throughts on just this:
- The stack should naturally do that already, so that&#39;s good for parameters and local variables.
- The heap could be managed in such a way that recently-freed memory is reused first. It would be interesting to know if that&#39;s already the case on existing platforms.</div>
</div>
<div class='comment'>
<div class='author'>plam</div>
<div class='content'>My student looked into &#39;unread writes&#39; via dynamic binary translation a few years ago. Appeared at RV 2012: &quot;Detecting Unread Memory using Dynamic Binary Translation.&quot; https://patricklam.ca/papers/12.rv.unread.pdf Summary: not as many as we&#39;d hoped.</div>
<div class='comment'>
<div class='author'>Robert</div>
<div class='content'>Interesting, but not the same thing that I&#39;m considering here. I&#39;m wondering about writes that may or may not be read, but where the last read (if any) occurs before the cache line is written back to RAM.</div>
</div>
</div>

</div>