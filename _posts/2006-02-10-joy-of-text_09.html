---
layout: "post"
title: "The Joy Of Text"
date: "2006-02-10 05:02:00 +0000"
categories: "Mozilla"
permalink: "/2006/02/joy-of-text_09.html"
---
<div class="columns"><a href="http://lxr.mozilla.org/seamonkey/source/layout/generic/nsTextFrame.cpp">nsTextFrame</a> is the core of our text layout and rendering. To the rest of the layout engine, it exposes an interface pretty much like that of any other inline frame. It consumes fairly simple platform-specific APIs for measuring and drawing strings of single-style text. It implements a whole lot of behaviour:<br/><ul><br/><li>Regular text measurement, layout, linebreaking and painting<br/><li>XML/HTML whitespace compression (for CSS "whitespace" not "pre")<br/><li>Text selection painting<br/><li>IME-specific selection/conversion painting<br/><li>CSS "word-spacing" and "letter-spacing"<br/><li>CSS "text-decoration" in "quirks mode" (including "text-decoration:blink")<br/><li>CSS "text-transform"<br/><li>CSS "font-variant:smallcaps"<br/><li>CSS "text-align: justify" (in conjunction with control logic in nsLineLayout)<br/></ul><br/>All this is really complex for a few reasons. For starters, the functionality itself is complex, especially when you take into account weird languages and scripts: e.g., the German "&szlig;" whose uppercase form is two characters, "SS", so uppercasing a string can actually change its length; various RTL issues; UTF16 surrogate pairs; and glyph clustering (when multiple Unicode code points combine to form an atomic cluster of glyphs). Furthermore we support a mix of platforms with different underlying capabilities, so some nsTextFrame code is only used on platforms that don't have a required capability. And of course text layout is a core part of Web rendering, and hence nsTextFrame is performance critical, so we have convoluted code to avoid copying text and to speed things up in other ways.<br/><br/>Unsurprisingly nsTextFrame has become very messy. Apart from the usual difficulties this causes us with bugfixing and performance, we also need to extend it to support text-overflow, hyphenation and other features. Furthermore, over the last several years the multilingual, multiscript text layout capabilities of our platforms have improved enormously, with the introduction and widespread availability of Uniscribe, Pango, and ATSUI. Now with the move to cairo-based rendering, it is time for a wholesale redesign of nsTextFrame.<br/><br/>The primary goal is to separate text handling into two abstractions, nsTextFrame and gfxTextRun. A gfxTextRun is a run of single-direction, single-style, single-language text. gfxTextRun is responsible for converting the text into a sequence of glyph clusters and rendering them. The implementation will be platform-specific and rely on platform APIs as much as possible. A new nsTextFrame implementation is being written that implements all the functionality of text frames on top of gfxTextRun. Based on our experiences with the current nsTextFrame, I have designed <a href="http://wiki.mozilla.org/Mozilla2:GFXTextRun">a gfxTextRun interface</a> which is fairly clean and around which we can hopefully build a much leaner, cleaner implementation of text frames. The actual implementation will build the real interface and implementation incrementally, and no doubt diverge a bit from the proposal, but I believe it's a good idea to think far enough ahead to have confidence we're heading to a coherent end point.<br/><br/>Currently Red Hat ships Firefox builds configured to use Pango underneath the existing nsTextFrame. These builds have notoriously poor performance. In SUSE we're going to enable these builds only in certain Indic locales likely to use scripts that the non-Pango builds are completely incapable of. In the new world I hope we can achieve much better performance, possibly even better performance than non-Pango builds today, because we'll be able to construct a gfxTextRun for an entire single-style text paragraph, eating the cost of glyph conversion and placement just once and then sharing it among all the text frames for that paragraph.<br/><br/>One interesting detail is that I think we can move text-transform and smallcaps out of text frames into specialized gfxTextRun implementations, treating them as nothing more than an extra processing pass during text to glyph conversion. This will help simplify nsTextFrame even more. Unfortunately nsTextFrame will still have to do whitespace compression as this depends on information from surrounding frames.<br/><br/>One implication of this plan is that we will not be fixing many bugs in the existing trunk nsTextFrame, unless they are candidates for landing on a FF1.5 or FF2 branch.</div><br/><br/>
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>Axel Hecht</div>
<div class='content'>Roc, could you comment on how rendering thai plays into this?<br>Maybe even as a follow up to that post in .i18n.<br></div>
</div>
<div class='comment'>
<div class='author'>Greg K.</div>
<div class='content'>So is the implication for gfxTextRun in the Mac world that ATSUI will get to handle paragraph-sized chunks of text?<br></div>
</div>
<div class='comment'>
<div class='author'>Robert Accettura</div>
<div class='content'>Got a few questions (pardon the ignorance).<br>1.  What perf impact would there be on Windows?  or Mac OS X?  Would there be any gain, or is this mainly for the benefit of Pango based builds?  Does this improve Cairo builds performance as well?<br>2.  Are there any major bugs in the current implementation that this would resolve?  Or is the big benefit that the code will be easier to manage in the future?<br>3.  Is there any printing impact?<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>&gt; Roc, could you comment on how rendering thai<br>&gt; plays into this?<br>I believe Thai line-breaking is tough, and we&#39;ll still be doing line-breaking in our frame code, so that will still be our problem. I believe Thai also requires special glyph positioning, shaping and/or clustering, and that will be handled by the underlying platform (Pango, Uniscribe, ATSUI).<br>&gt; So is the implication for gfxTextRun in the Mac<br>&gt; world that ATSUI will get to handle<br>&gt; paragraph-sized chunks of text?<br>Yes and no. We will only passing single-style chunks of text to ATSUI, so if you use  inside your paragraph, ATSUI will only see one piece of the paragraph at a time. Also, we won&#39;t be using ATSUI for line breaking, ATSUI will just be laying it out as a really long line that we&#39;ll then chop up.<br>&gt; 1. What perf impact would there be on Windows?<br>&gt; or Mac OS X? Would there be any gain, or is<br>&gt; this mainly for the benefit of Pango based<br>&gt; builds? Does this improve Cairo builds<br>&gt; performance as well?<br>It&#39;s dangerous to speculate in advance of the facts. Performance is certainly a paramount concern. I don&#39;t know how well Uniscribe or ATSUI perform. If they suck, then we can always implement faster paths in the platform gfxTextRun implementation (e.g., do something simple and fast for ASCII). One thing I perhaps didn&#39;t make clear is that this is all for cairo builds *only*.<br>&gt; 2. Are there any major bugs in the current<br>&gt; implementation that this would resolve? Or is<br>&gt; the big benefit that the code will be easier to<br>&gt; manage in the future?<br>Our current code completely sucks for many Indic languages, and this will fix that (as long as the platform handles such languages well; Pango does). It will probably fix a lot of other I18N bugs where the underlying platform does better than us; no doubt there will be some unfixable regressions where the underlying platform does worse (switch platforms!).<br>It will also make it much easier to fix &quot;bugs&quot; like &quot;Gecko doesn&#39;t handle HTML soft hyphens&quot;.<br>&gt; 3. Is there any printing impact?<br>Not particularly, unless the underlying platform APIs have problems with printer font metrics. One would hope they don&#39;t.<br></div>
</div>
<div class='comment'>
<div class='author'>Stefan Moebius</div>
<div class='content'>I&#39;m trying to understand this, having no clue yet about how nsTextFrame works now or will work in the future.<br>1. How does gfxTextRun relate to, e.g., CSS &quot;writing-mode:tb&quot;?<br>2. Do layout changes (e.g., on window resize) lead to a complete recreation of the gfxTextRun objects in a nsTextFrame?<br>BTW, if there&#39;s any documentation on nsTextFrame as it is or any documentation-to-emerge on how it will be, I&#39;d be grateful for a pointer to it.<br></div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>&gt; the German &quot;�&quot; whose uppercase form is two characters, &quot;SS&quot;,<br>Shouldn&#39;t &quot;�&quot;.toUpperCase(); return &quot;SS&quot; then?<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>&gt; 1. How does gfxTextRun relate to, e.g., CSS<br>&gt; &quot;writing-mode:tb&quot;?<br>It can be used by &quot;writing-mode:tb&quot;, but writing-mode:tb is not part of this plan.<br>&gt; 2. Do layout changes (e.g., on window resize)<br>&gt; lead to a complete recreation of the gfxTextRun<br>&gt; objects in a nsTextFrame?<br>No, that won&#39;t change any gfxTextRuns.<br>&gt; BTW, if there&#39;s any documentation on nsTextFrame<br>&gt; as it is or any documentation-to-emerge on how<br>&gt; it will be, I&#39;d be grateful for a pointer to it.<br>There isn&#39;t much of either.<br>&gt; Shouldn&#39;t &quot;�&quot;.toUpperCase(); return &quot;SS&quot; then?<br>You mean in Java? I suppose it should.<br></div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>&gt;&gt; Shouldn&#39;t &quot;�&quot;.toUpperCase(); return &quot;SS&quot; then?<br>&gt; You mean in Java? I suppose it should.That&#39;s what<br>http://www.fileformat.info/info/unicode/char/00df/ agrees for Java, but FYI in JavaScript Tools &gt; JavaScript Console, paste in<br>alert(&quot;b��&quot;.toUpperCase())<br>You get &quot;B��&quot;: same � letter, same length.<br></div>
</div>
<div class='comment'>
<div class='author'>jmdesp</div>
<div class='content'>Roc, when I read the following :<br>&gt; I believe Thai also requires special glyph<br>&gt; positioning, shaping and/or clustering, and that<br>&gt; will be handled by the underlying platform<br>&gt;(Pango, Uniscribe, ATSUI).<br>&gt; We will only passing single-style chunks of text<br>&gt; to ATSUI, so if you use inside your paragraph,<br>&gt; ATSUI will only see one piece of the paragraph<br>&gt; at a time. Also, we won&#39;t be using ATSUI for<br>&gt; line breaking, ATSUI will just be laying it out<br>&gt; as a really long line that we&#39;ll then chop up.<br>&gt; It will also make it much easier to fix &quot;bugs&quot;<br>&gt; like &quot;Gecko doesn&#39;t handle HTML soft hyphens&quot;.<br>I conclude that you expect to be able to do the line chopping and therefore hyphens on glyphs, not characters.<br>You might run into problems and get something not so easy to make work with complex scripts.<br>But then after all, I&#39;m not sure there any easy alternative. I read OpenType handles glyph and characters in parallel and knows the correspondance, but I don&#39;t know if it can be achieved with Uniscribe/ATSUI/Pango.<br>I cross-posted references this on news://mozilla.dev.i18n<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>&gt; I conclude that you expect to be able to do the<br>&gt; line chopping and therefore hyphens on glyphs, not<br>&gt; characters.<br>Line break positions will be selected using our existing code, which works on characters (well, UTF16...)<br>Hyphenation will only work where soft-hyphens have already been inserted by the author, or possibly where we have hyphenation dictionaries, so at least initially it will only work automatically on simple languages.<br></div>
</div>
<div class='comment'>
<div class='author'>jmdesp</div>
<div class='content'>I don&#39;t know if I&#39;m stupid or what, but I didn&#39;t understand.<br>You say first UPA (Uniscribe, Pango, ATSUI) will be responsible for things like glyph positioning, shaping and/or clustering.<br>And will give as a result extended uncut long lines of text.<br>Then, the existing code will select line break position.<br>I don&#39;t see how UPA can do that and output characters and not glyphs.<br>Do you intend to insert  possible line break in the string beforehand ?<br>But that would certainly break the UPA clustering<br>code.<br>I just spent some time checking how this is done in Uniscribe.<br>The conclusion is that UPA will certainly gives out both glyph and the info necessary for the line breaking, and it&#39;s not necessary useful to continue using the old code for that.<br>Based on the info on those pages :<br>http://msdn.microsoft.com/library/default.asp?url=/library/en-us/intl/uniscrib_9t2d.asp<br>http://msdn.microsoft.com/library/default.asp?url=/library/en-us/intl/uniscrib_7yhx.asp<br>(especially the description of cluster array/character array/glyph array in remarks of ScriptShape)<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>&gt; Do you intend to insert possible line break in the<br>&gt; string beforehand ?<br>&gt; But that would certainly break the UPA clustering<br>&gt; code.<br>Only if we decide to break between characters that UPA wants to form a glyph cluster. That would be a bug in our line breaking code.<br>It might make sense to eventually get line-breaking information from UPA. However, ultimate control has to stay with nsTextFrame so we can do hyphenation, CSS &#39;whitespace&#39;, and other effects. Given that, the simplest thing to do for now, while we get everything else working, is to keep on getting line-break information the way we currently do.<br></div>
</div>
<div class='comment'>
<div class='author'>samphan</div>
<div class='content'>Does that mean that you plan to use the same interface nsILineBreaker and the implementation nsJISx4501LineBreaker?<br>Do you have any plan to revise the interface/implementation?<br>It&#39;s a hard to implement the interface efficiently in UPA. Especially BreakInBetween() which recieves two unconnected strings while UPA breakers accept only one string. You have to copy the two strings to a newly allocated buffer everytime the function is called.<br></div>
</div>
<div class='comment'>
<div class='author'>jmdesp</div>
<div class='content'>&gt; Only if we decide to break between characters<br>&gt; that UPA wants to form a glyph cluster. That<br>&gt; would be a bug in our line breaking code.<br>It&#39;s a bad world. The hyphens points for the french &quot;effectivement&quot; are &quot;ef-fec-ti-ve-ment&quot;, but still &#39;LATIN SMALL LIGATURE FF&#39; (U+FB00) applies to this word.<br>But the correct method now seems clear to me.<br>Both Uniscribe and Pango have a word breaking function that works on characters :<br>pango_break and ScriptBreak.<br>And both have a methode to link each glyph to the corresponding initial character(s) :<br>cluster array of ScriptShape for Uniscribe, and gint *log_clusters inside PangoGlyphString as output of pango_shape.<br>So you generate and measure the glyphs, see before which glyph you need to break, and then get back to the character that corresponds, and finally choose the appropriate break point using a character based breaking function.<br>You also reshape the string after breaking to handle case like &#39;ef-fectivement&#39; where the break can occur in the middle of what used to be a glyph.<br>pango_break and ScriptBreak are only informative, they don&#39;t do the break, so they can be used as a direct replacement for what exists in the current line-break algorythm.<br>And that way, they would bring with them thai word breaking without any developments.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>samphan: If we start taking line-break information from UPA, we&#39;ll use completely new interfaces.<br>jmdesp:<br>&gt; It&#39;s a bad world. The hyphens points for the<br>&gt; french &quot;effectivement&quot; are &quot;ef-fec-ti-ve-ment&quot;,<br>&gt; but still &#39;LATIN SMALL LIGATURE FF&#39; (U+FB00)<br>&gt; applies to this word.<br>This isn&#39;t really a problem, since it&#39;s OK to break and not cluster. The situation we need to avoid is where we break between two characters that *must* cluster in order to get a correct rendering.<br>What you suggest sounds like a good direction to go, but we&#39;re not going there right away.<br></div>
</div>
<div class='comment'>
<div class='author'>jmdesp</div>
<div class='content'>Roc, I&#39;m testing the latest cairo based windows build on trunk. I&#39;ve seen some thai problems, but it seems to be bug 324560.<br>glyph cluster for arabic did progress, but can not be mixed with formatting like IE can do as shown here  http://www.catch22.net/tuts/editor12.asp.<br>I played with this one for some tests that give really funny results, I hope to put them on line soon :-)<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Most of what I talked about here is not implemented yet.<br></div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>I was very happy to come across your post, since the current state of the Mozilla text rendering system is causing some wild breakage now that Pango supports ligatures:<br>https://bugzilla.mozilla.org/show_bug.cgi?id=331716<br>https://launchpad.net/distros/ubuntu/+source/firefox/+bug/37828<br>Do you suppose a quick fix could be released for the above problem, hopefully in time for the Ubuntu 6.06 release on 1 June, rather than having to wait for the grand rearchitecting?  The DejaVu font project<br>http://dejavu.sourceforge.net/<br>has already taken the rash and regrettable step of removing the standard ligatures (i.e., making them �discretionary�), which is a pity seeing that it isn�t even their bug and that the majority of other fonts will actually also trigger it.<br></div>
</div>
<div class='comment'>
<div class='author'>Stefan</div>
<div class='content'>I was very happy to come across your post, since the current state of the Mozilla text rendering system is causing some wild breakage now that Pango supports ligatures:<br>https://bugzilla.mozilla.org/show_bug.cgi?id=331716<br>https://launchpad.net/distros/ubuntu/+source/firefox/+bug/37828<br>Do you suppose a quick fix could be released for the above problem, hopefully in time for the Ubuntu 6.06 release on 1 June, rather than having to wait for the grand rearchitecting?  The DejaVu font project<br>http://dejavu.sourceforge.net/<br>has already taken the rash and regrettable step of removing the standard ligatures (i.e., making them �discretionary�), which is a pity seeing that it isn�t even their bug and that the majority of other fonts will actually also trigger it.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Stefan, unfortunately the Pango code that&#39;s causing problems there is a bit of a hack from Red Hat, not really supported by Mozilla itself.<br></div>
</div>
<div class='comment'>
<div class='author'>Stefan</div>
<div class='content'>Yes, I was following the discussion over at<br>https://bugzilla.mozilla.org/show_bug.cgi?id=331716<br>But it�s not just a Pango problem either, is it?  Earlier today, I was looking at<br>http://depts.washington.edu/ebmp/bibliography.php<br>in Firefox on Windows on one of the university�s public computers, and the Devanagari in the first entry was completely broken (no combining at all) when viewed with the default stylesheet (justified text), but rendered correctly when I switched off all stylesheets (left‐aligned text).<br>Anyway, I am very happy that cleaning up text rendering is now one of the top priorities of the Mozilla project, and wish you much success and speedy progress.  Until then, I (and India etc.) will have to live with whatever functionality the bit of a hack from Red Hat provides.  Switching off complex‐script rendering, however broken, is not really an option.<br>Thank you for your work on this!<br></div>
</div>
<div class='comment'>
<div class='author'>Indic</div>
<div class='content'>Between Pango and Gecko, Indic users of Ff (on Linux) are screwed.<br>https://launchpad.net/distros/ubuntu/+source/firefox/+bug/37828/<br></div>
</div>

</div>