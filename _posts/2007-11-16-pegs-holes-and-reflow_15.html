---
layout: "post"
title: "Pegs, Holes And Reflow"
date: "2007-11-15 11:55:00 +0000"
categories: "Mozilla"
permalink: "/2007/11/pegs-holes-and-reflow_15.html"
---
<div class="columns"><p>I already blogged about <a href="/2007/10/if_i_did_it.html">Gecko's frame continuations</a> being a mistake. It's time to rant about another big layout design error: the uniformity of the Reflow() API.<br/><p>During layout, frames (i.e. CSS boxes) call Reflow to lay out their children and then position those children in some manner. The core problem is that Reflow's signature is the same for every frame type. That means that in theory, table frames have to interact with their row(group) frames in exactly the same way that inline frames have to interact with their inline children, or XUL boxes have to interact with their box children, etc. But this is nonsense, since the invariants, dependencies and data that need to cross the parent/child boundary are entirely different in each of these cases.<br/><p>So in practice we have various kinds of magic probing and/or magic fields of structures that are only used in certain cases. This inevitably leads to breakage and overcomplex code. Problems are particularly acute in line layout, where we really would like to work with a flattened list of inline leaf items, but thanks to Reflow we can't. The textrun work has moved us to a situation where we construct a flattened representation of at least the text of a paragraph for line breaking and text shaping, and then we pull data from that in a hokey way as we Reflow text frames. It's somewhat painful as the two traversal models fight each other in nsLineLayout. Of course the aforementioned frame continuations crash the party too.<br/><p>What we really should do is admit that parent-child frame type pairs are actually tightly constrained, i.e. an inline frame can only have an inline parent or a block parent, a table row frame can only have a table rowgroup parent which can only have a table parent, etc. (These invariants already exist actually, although the code sometimes doesn't want to admit it.) Then we should toss Reflow over the side and give each frame type its own specialized layout interface. Only a few frame types (e.g. blocks and tables) would be able to occur in "unknown" contexts and offer a generic layout interface.<br/><p>In fact, we could go further and specialize further the types of child frames or even get rid of a uniform nsIFrame tree altogether. There's no particular reason why it makes sense to have tables, table rowgroups, table rows and table cells all be the same kind of object as text frames or SVG frames. Sure, we want to be able to iterate over CSS box tree geometry and style somehow, but there's a whole lot of generality exposed in nsIFrame that doesn't really make sense everywhere.<br/><p>As an aside, the conflict between textrun layout and inline layout is an example of a general problem I've seen with cleaning up code. You rework module A to make it nice and clean, but because modules B and C are quirky, you have to add complexity to module A to keep things working and shippable. Eventually you rework B and C too but A's already been contaminated, so B and C inherit some of the sins of their fathers. You can reduce the effect by enlarging the scope of rework, but that adds risk and schedule issues of course --- in the limit you rewrite everything and sink your entire project.</div><br/><br/>
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>Gus</div>
<div class='content'>I ran the above, with the typo correction and want to let you know that I believe it to be a Redraw/Reflow problem. Slide something over it and when you uncover it, it&#39;s corrected. I checked the bug and found no mention of this, so I hope it helps.<br></div>
</div>
<div class='comment'>
<div class='author'>itwn</div>
<div class='content'>Okay now I&#39;m confused. Is the following bug 367576 due to the original problem in this post, or the one about nsTableCellFrame in the first comment?<br>&lt;table rules=&quot;rows&quot;&gt;<br>&lt;caption&gt;This table has rules=&quot;rows&quot;:&lt;/caption&gt;<br>&lt;tr&gt;&lt;td&gt;Normal cell&lt;/td&gt;&lt;td rowspan=&quot;2&quot;&gt;This cell has rowspan=&quot;2&quot;&lt;/td&gt;&lt;/tr&gt;<br>&lt;tr&gt;&lt;td&gt;Normal cell&lt;/td&gt;&lt;/tr&gt;<br>&lt;tr&gt;&lt;td style=&quot;border-bottom: 16px solid black&quot;&gt;border-bottom: 16px solid black&lt;/td&gt;&lt;td style=&quot;border-top: 16px solid black&quot; rowspan=&quot;3&quot;&gt;This cell has rowspan=&quot;3&quot; and&lt;br&gt;border-top: 16px solid black&lt;/td&gt;&lt;/tr&gt;<br>tr&gt;&lt;td&gt;Normal cell&lt;/td&gt;<br>&lt;/tr&gt;&lt;tr&gt;<br>&lt;td style=&quot;border-bottom: 2px solid black&quot; rowspan=&quot;2&quot;&gt;This cell is rowspan=&quot;2&quot; and&lt;br&gt;border-bottom: 2px solid black&lt;/td&gt;<br>&lt;/tr&gt;&lt;tr&gt;<br>&lt;td&gt;Normal cell&lt;/td&gt;<br>&lt;/tr&gt;<br>&lt;/table&gt;<br>The cell border from the first column escapes into the inner part of the second column cell.<br></div>
</div>
<div class='comment'>
<div class='author'>Boris</div>
<div class='content'>I sometimes wonder whether XUL&#39;s approach of having the layout algorithm live outside the boxes is the way to go.  If we did it right, for example, that would allow this markup to work per spec:<br>&lt;div style=&quot;display: table-row&quot;&gt;<br>&lt;span style=&quot;display: table-cell&quot;&gt;<br>An image:<br>&lt;/span&gt;<br>&lt;img style=&quot;diplay: table-cell&quot;&gt;<br>&lt;/div&gt;<br>Right now it doesn&#39;t work because table rows (and tables in general) assume they can cast the relevant frames to nsTableCellFrame...<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>That&#39;s a slightly different problem I think --- the problem that frame types are overloaded for different uses. We use them to control external layout behaviour (CSS3 display-role) and also internal layout behaviour (CSS3 display-model), and to control replaced-element behaviour (which is akin to display-model). And of course we also tie in other things like abs-pos-container-ness (to nsBlockFrame). When we need extra behaviours we create wrapper frame types like nsHTMLScrollFrame and nsColumnSetFrame, but wrapper frames have their own problems (like insertion point confusion).<br></div>
</div>

</div>