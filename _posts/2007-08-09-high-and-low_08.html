---
layout: "post"
title: "High And Low"
date: "2007-08-08 13:45:00 +0000"
categories: "New Zealand"
permalink: "/2007/08/high-and-low_08.html"
---
<div class="columns"><p>Yesterday I visited Otago University and gave a guest lecture in a software deveopment class there, titled "Developing Firefox". This was a revised version of my "Firefox For CS Researchers" talk, with most of the "future Web developments" and "how this relates to CS research" stuff ripped out and replaced with greater discussion of our development tools, processes and issues. As it turned out I had way too much material for the time available so I also ended up leaving out the discussion of security issues, but that's OK for this version of the talk. I took some interesting questions and talked to some students after the talk for a while.<br/><p>It's becoming clear that NZ universities steer students towards "safe languages and frameworks" used by IT and Web front/backends, and away from the sort of low-level systems programming required for infrastructure projects such as Gecko. That's understandable --- high-level is where the majority of jobs are, and I'm glad the industry has matured so people no longer write bespoke apps in C and C++ --- but it's also sad, because I think low-level stuff is more interesting in many ways, and tends to have more leverage in its ability to change the world. There <em>is</em> actually a great need worldwide for good low-level engineering and if we have a reservoir of talent here, jobs will flow here too. We don't have to just be another consumer of platforms produced elsewhere. Maybe one NZ university should focus on this while the others feed the IT shops.<br/><p>(By 'low level' here I don't mean "assembler" or "C" --- I mean low in the software stack: infrastructure and frameworks that provide APIs and languages that other developers build on. For performance, footprint and other reasons this layer is more likely to be written in lower-level languages. I'm well aware of various efforts to write "systems code" in "high-level" languages, and I'm willing to discuss them with the proponents of those languages in comments :-).)<br/><p>For our recruiting this means the interesting applicants are people who have either done some particular project that required systems programming (sometimes at university, e.g. a Masters thesis), or have just done some on the side for a hobby project. At Otago I exhorted students to consider contributing to suitable open source projects to get this kind of experience. I proposed that such experience opens many interesting career paths, some involving open source projects, but many others as well.<br/><p>Tomorrow I'm visiting Waikato University to give both the "Developing Firefox" and "Firefox For CS Researchers" talks. It'll be interesting to see how things compare.</div><br/><br/>
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>Colin Coghill</div>
<div class='content'>I teach programming at Uni of Auckland, and while we do focus on low level (hardware access, memory manipulation, C,  asm, CPU design, network protocols), there&#39;s nothing I&#39;m aware of dealing with designing infrastructure, a good API, library or language, or even just designing a good IDE.<br>You&#39;re right, it would be a really useful thing to add in to a Software Engineering programme.<br>(I&#39;m Engineering rather than Comp Sci - that probably makes a bit of a difference.)<br>I shall talk to my colleagues :)<br>- Colin<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Maybe you teach them that stuff in principle, but the students who I&#39;ve been in touch with don&#39;t claim to have experience in it. Is it that they don&#39;t use low-level languages for their project classes?<br>I don&#39;t want to simply advocate &quot;teach more!&quot; That doesn&#39;t work. I would advocate that some students should practise lower-level skills and should *not* be taught IT-oriented subjects like, say, databases.<br></div>
</div>
<div class='comment'>
<div class='author'>Colin Coghill</div>
<div class='content'>I&#39;d be interested in any comments you have about any students you&#39;ve come into contact with who have an Engineering background compared to a Science background. We, of course, only get to see them as we pat them on the back and send them out the door, they quite possibly forget everything they&#39;ve supposedly learned at that moment :)<br>The three undergraduate &quot;programming&quot; programmes I&#39;m aware of at UofA are Computer Science, Software Engineering, and Computer Systems Engineering.<br>The Computer Systems Engineers do lots of hardware, microcontrollers, network protocols, but are weaker at programming. The Software Engineers study development methods, project planning, and a bit of design, and I&#39;m sure you&#39;re familiar with the Computer Science programme, it hasn&#39;t changed all that much since we went through it, although it&#39;s possibly more &quot;industry&quot; oriented, (where &quot;industry&quot; = &quot;programmer farms&quot;).<br>I do think Universities need to be changing their focus a bit, they really do seem to be trying their best to become vocational schools that churn out mediocre Java/C# application programmers.<br>Because, sadly, that&#39;s what the students think they want to do :(<br>- Colin<br></div>
</div>
<div class='comment'>
<div class='author'>Geoff Langdale</div>
<div class='content'>I agree with Robert on this one. Low-level skills and knowledge are something that is fading from curricula here in Australia (although UNSW has a good reputation), as the field becomes oriented towards &quot;IT&quot; (or the even more repulsive &quot;ICT&quot;) rather than &quot;CS&quot;.<br>Part of the problem is that many of the potentially good &#39;systems&#39; courses instead are comprised of two separate components:<br>Part A: &#39;General knowledge quiz&#39; approach to architecture / networks / ..., where one reads a textbook, works through a few contrived examples, and then answers shallow questions in an exam:<br>Tomasulo&#39;s algorithm is a register scoreboarding algorithm (T/F): ___<br>Part B: &#39;Pseudo-programming question&#39;: simulate a small component of a cache hierarchy / network stack / disk scheduler by filling in 4 missing functions in a Java program.<br>Glue these two bits together, and congratulate yourself that you&#39;ve now got a well-rounded systems course covering theory and practice!<br>Part of the problem is that the students don&#39;t learn enough programming in lower level courses to do anything interesting. Also a problem is that many of these courses (networks, os, architecture, compilers) wind up on critical paths for non-specialists and become courses that mediocre or distracted students still have to receive more or less automatic passes for fear of generating inter-departmental strife.<br></div>
</div>
<div class='comment'>
<div class='author'>Matt</div>
<div class='content'>I graduated from college 2 years ago (US not NZ), and we didn&#39;t focus very much on the low-level coding.  We had one sophomore level class that tied together c/assembly/computer architecture, and then we had an OS class that was very programming heavy and used C/C++.  Other than that, most classes tended to be freshman level &quot;do this in Java&quot; assignments, or upper level &quot;do this project in whatever language you want&quot; assignments.<br>I disagree about not teaching databases though.  Almost every project I&#39;ve ever worked on has used a database, and even firefox is hooked up to one now.  Sure, you can learn it on your own but I could say that about half the classes I took as an undergrad.<br>I probably would have axed formal language theory, a completely redundant statistics class, and the technology ethics class we had to take from the curriculum in favor of some of the more systems level programming and designing APIs, but I&#39;m sure others would think those are less important.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>The standard &quot;hack on a toy OS in C&quot; class that a lot of US universities have is lacking here. That&#39;d be a good class to help prepare students for our work.<br>Unfortunately that class is usually one of the more brutal ones, and one thing I *don&#39;t* want to import from the US is the massive workload imposed on undergrads at the top universities. That&#39;s why I wouldn&#39;t propose adding any new classes without also proposing a class it should replace :-).<br></div>
</div>
<div class='comment'>
<div class='author'>Colin Coghill</div>
<div class='content'>The &quot;what to drop&quot; question is a hard one, very few programmes I&#39;ve seen at NZ universities have anything I&#39;d consider inappropriate or of lesser value.<br>For me an ideal software engineering course would have many electives in the final year, with the student able to choose three or four from a range of options. networking, distributed, operating systems, user interfaces, agile development, large team development, tools, scientific computing, databases, etc.<br>Smaller specialized classes are a lot more fun to teach, the students learn a lot more, and you get a much broader range of graduates.<br>Unfortunately given the current funding models, electives cost a lot. Two classes of 20 students costs almost twice as much to run as one class of 40, but brings the same income into the university.<br>And software development (as opposed to IT) really doesn&#39;t pull in the numbers any more. Most people seem to come in wanting a solid job translating pseudocode into C#. And given their current funding models, the universities take in anyone they can find and shove them all into the same classes.<br>- Colin<br></div>
</div>
<div class='comment'>
<div class='author'>David Xie</div>
<div class='content'>Hi Robert, thanks for your lecture @ Otago, I really enjoyed it.  Best wishes to you and your team @ Auckland :)<br></div>
</div>

</div>