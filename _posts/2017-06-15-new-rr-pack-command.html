---
layout: "post"
title: "New \"rr pack\" Command"
date: "2017-06-14 12:51:00 +0000"
categories: "rr Mozilla"
permalink: "/2017/06/new-rr-pack-command.html"
---
<p>I think there's huge potential to use rr for debugging cloud services. Apparently right now interactive debugging is mostly not used in the cloud, which makes sense &mdash; it's hard to identify the right process to debug, much less connect to it, and even if you could, stopping it for interactive analysis would likely interfere too much with your distributed system. However, with rr you could record any number of process executions without breaking your system, identify the failed runs after the fact, and debug them at your leisure.
<p>Unfortunately there are a couple of problems making that difficult right now. One is that the largest cloud providers don't support the hardware performance counter rr needs. I'm excited to hear that Amazon has recently <a href="http://www.brendangregg.com/blog/2017-05-04/the-pmcs-of-ec2.html">enabled some HW performance counters</a> on dedicated hosts &mdash; hopefully they can be persuaded to add the retired-conditional-branch counter to their whitelist (and someone can fix the <a href="https://lists.xen.org/archives/html/xen-devel/2016-10/msg01542.html">Xen PMU virtualization bug</a> that breaks rr). Another problem is that rr's traces aren't easy to move from one machine to another. I've started addressing this problem by <a href="https://github.com/mozilla/rr/commit/a2a91adad09daa478f3a00aa102e169814abb40a">implementing a new rr command</a>, <tt>rr pack</tt>.
<p>There are two problems with rr traces. One is that on filesystems that do not support "reflink" file copies, to keep recording overhead low we sometimes hardlink files into the trace, or for system libraries we just assume they won't change even if we can't hardlink them. This means traces are not fully self-contained in the latter case, and in the former case the recording can be invalidated if the files change. The other problem is that every time an mmap occurs we clone/link a new file into the trace, even if a previous mmap mapped the same file, because we have no fast way of telling if the file has changed or not. This means traces appear to contain large numbers of large files but many of those files are duplicates.
<p><tt>rr pack</tt> fixes both of those problems. You run it on a trace directory in-place. It deduplicates trace files by computing a cryptographic hash (BLAKE2b, 256 bits) of each file and keeping only one file for any given hash. It identifies needed files outside the trace directory, and hardlinks to files outside the trace directory, and copies them into the trace directory. It rewrites trace records (the <tt>mmaps</tt> file) to refer to the new files, so the trace format hasn't changed. You should be able to copy around the resulting trace, and modify any files outside the trace, without breaking it. I tried pretty hard to ensure that interrupted <tt>rr pack</tt> commands leave the trace intact (using <tt>fsync</tt> and atomic <tt>rename</tt>); of course, an interrupted <tt>rr pack</tt> may not fully pack the trace so the operation should be repeated. Successful <tt>rr pack</tt> commands are idempotent.
<p>We haven't really experimented with trace portability yet so I can't say how easy it will be to just zip up a trace directory and replay it on a different computer. We know that currently replaying on a machine with different CPUID values is likely to fail, but we have a solution in the works for that &mdash; Kyle's patches to add <a href="https://lwn.net/Articles/721581/">ARCH_SET_CPUID</a> to control "CPUID faulting" are in Linux kernel 4.12 and will let rr record and replay CPUID values.