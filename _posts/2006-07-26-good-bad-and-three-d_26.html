---
layout: "post"
title: "The Good, The Bad, And The Three-D"
date: "2006-07-26 08:31:00 +0000"
categories: "Mozilla"
permalink: "/2006/07/good-bad-and-three-d_26.html"
---
<div class="columns">Last Friday I visited <a href="http://lindenlab.com">Linden Lab</a>, makers of <a href="http://secondlife.com">Second Life</a>, to spend several hours talking with Callum, author of <a href="http://ubrowser.com">UBrowser</a>. UBrowser is an interesting Gecko embedding that needs to direct all rendering to an offscreen area so it can be transformed by OpenGL for display. A surprising number of people have contacted me over time requesting help with this kind of problem, and I'd like to have all these people collaborating on a solution that can be properly supported in the Mozilla tree.<br/><br/>We need to choose between two alternative approaches:<br/><ul><br/><li>Extend existing Gecko ports, e.g. the Windows port, to support offscreen embedding<br/><li>Create a new Gecko port that does not depend on any window system --- the "membuf approach" taken by the first effort in this space, <a href="http://interreality.org/projects/crystalzilla/">Crystalzilla</a><br/></ul><br/>The decision is not clear-cut. For a long time I favoured the membuf approach because it's somewhat cleaner, portable, and could run on headless servers. But with more thought and after talking things through with Callum, I favour extending existing platform ports, for the following reasons:<br/><ul><br/><li>The changes required to Mozilla code turn out to be very minor. The membuf approach requires a significant amount of new code.<br/><li>A separate membuf port would be poorly maintained compared to the platform code that everyone else uses.<br/><li>Some important things such as plugins and native themes would be difficult or impossible with membuf.<br/><li>There are a few things that are harder to do when the native platform gets in the way, but nothing major. For example Mozillla windows must be hidden. Platforms seem to be able to do this OK.<br/><li>If support in headless servers is required, they'll just have to run Xvfb or Xvnc; not an ideal solution, but probably practical.<br/></ul><br/><br/>The plan is to work towards getting the UBrowser code ported to Linux and it and its support patches landed in Mozilla's CVS tree. Then people can use it as a starting point for their own embedding projects and start collaborating on improvements. The code is already xulrunner-based which is great.<br/><br/>Before my visit I had been confused by reports that plugins actually work in UBrowser, since I knew of no way to redirect plugin rendering to an offscreen bitmap. It turns out that the patch detects the offscreen painting case on Windows and asks plugins to print themselves via the NPAPI Print command, and Flash honours this. Other plugins such as Quicktime don't. We can't detect when the Flash plugin wants to repaint its window so UBrowser just updates it at 15Hz. Input events don't work in any plugin although that can probably be faked. On Linux we can probably solve these issues using the X Composite and Damage extensions, but I'm not sure what we can do on Mac or how we can complete the job on Windows. Nevertheless it's a step forward. It means that once we land this patch, the canvas drawWindow API will paint Flash content on Windows, which will be a nice bonus for the tab-preview extensions.<br/><br/>While there I also learned a lot about Second Life. It's a very interesting virtual world focused on the creativity and commerce of its residents. I think there's enormous potential for invention and fun --- and also vice. I certainly hope that people find ways to use it for more good than evil. Either way, I'm sure that Second Life is going to be extraordinarily successful.</div><br/><br/>
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>grumpY!</div>
<div class='content'>interesting to hear more comments about secondlife (SL). i am convinced that something like SL will take over the webstack by 2015. by &quot;something like SL&quot;, i mean something highly graphical, and highly concurrent. i am convinced the &quot;web stack&quot; will hit a wall in trying to bring true interactivity to users, and new protocols (low latency, concurrent, etc) will have to be created. i hope that the mozilla foundation will take a leading role in helping define whatever future may follow the web stack.<br></div>
</div>
<div class='comment'>
<div class='author'>christian biesinger</div>
<div class='content'>This is sort of unrelated to the main topic of this posting, but on the issue of Second Life this tech talk is pretty interesting:<br>http://video.google.com/videoplay?docid=-5182759758975402950<br></div>
</div>
<div class='comment'>
<div class='author'>Ian</div>
<div class='content'>Would Cairo make this easier at all? Is it feasible to create a Cairo backend which paints to an off-screen buffer?<br>With regards to Quicktime, I would have thought it would be better to work on something like Media Player Classic instead, whereby we could (a) see the code and fix bugs and (b) install it automatically via the update service.<br></div>
</div>
<div class='comment'>
<div class='author'>Chris Nelson</div>
<div class='content'>Interesting -- this is the second time &quot;Second Life&quot; has come to my attention in the past two days. An ex-colleague of mine recently took a job there...<br>hmm. I need to look into this more.<br></div>
</div>
<div class='comment'>
<div class='author'>Cory Ondrejka</div>
<div class='content'>Thanks, Roc!  It was great to meet you and Callum has made some serious progress since you were here.<br>Slightly off topic: if anyone reading this wants to help us solve the remaining Mozilla problems, please drop me a line (cory at secondlife dot com) because we are continuing to hire developers -- including remote developers -- like crazy.<br></div>
</div>
<div class='comment'>
<div class='author'>Paul Colton</div>
<div class='content'>Robert, I&#39;d love to talk to you about our efforts in this space. Can you contact me at paul at aptana dot com?<br>Paul Colton<br>http://www.aptana.com<br></div>
</div>
<div class='comment'>
<div class='author'>Anonymous</div>
<div class='content'>Great to hear there is some progress in this direction!<br>The headless xulrunner capability is certainly something lots of people have looked at for several years (five or more).  The core capability people seem to be looking for is an easy way to use the wonderful rendering capability in the Mozilla code base for a whole variety of different and interesting projects.<br>There are dozens of requests in many newsgroups from people expecting it ought to be possible (and easy), and being very surprised that no straightforward capability has ever been built in.<br>It is certainly possible to move in an Xvfb direction to eliminate the need for a display, and we currently use that approach after trying many others.  However, it adds a whole bundle of complexity outside the application especially when there may be several virtual displays going (and if the capability becomes widely used, they could be from several different applications).  Detecting, starting and stopping the right Xvfb services is difficult to do reliably (at least in our limited experience).  We have done the same thing under Windows, where we had to write a virtual framebuffer driver to give us some Xvfb-like capabilities.<br>It also means that any application wanting to use the xulrunner rendering capability needs to run X I think. This is a further disadvantage in terms of size and overhead, all just to fudge a display buffer.<br>There are other needs in a highly useable rendering system, including rendering items that are not on the web.  Mozilla/Firefox still crashes under Linux if the equivalent of the OnBeforeNavigate event is captured for the purposes of redirection, and nasty dialogs still appear when the browser trips across a missing file link when working locally from disk (even before there is any event that can be captured reliably to prevent it).<br>The long and the short of it is that taking an Xvfb approach may make the Mozilla code simpler and more mainstream, but it pushes the burden of size, complexity, maintainability onto the developers.  It destroys a lot of the out-of-the-box straightforward functionality that could be achieved, because there is a whole set of other knowledge and skills that becomes necessary to tackle that simple hypothetical rendering job.<br>Having suffered with this for several years now, and having been tantalised with various descriptions of embedding Gecko and being able to use it as an independent rendering agent, I *beg* you to reconsider the direction.  And with our suffering so far, it truly is *begging*.<br>We would certainly love to help.  Our knowledge of Mozilla internals is a lot less than our knowledge of real-world applications where browser and rendering capability is needed, perhaps part of our contribution would be on requirements and testing?<br>If we can help in any way (or bribe anyone to do what&#39;s hard but right) please contact me at jsinton at cavelle dot com.  All the best.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>jsinton: Thanks for writing, but I&#39;m afraid I&#39;m not yet convinced...<br>I&#39;m surprised that using Xvfb seems so hard; it shouldn&#39;t be. You say that starting and stopping the right Xvfb services is hard, but it seems to me that you could write a script that starts Xvfb, starts xulrunner, and then when xulrunner exits, kills the Xvfb it started. Why doesn&#39;t that work? If this is complicated to get right, perhaps we just need to collaborate a packaged solution that does it right.<br>I don&#39;t know what the cost of Xvfb is but it shouldn&#39;t be that high because it&#39;s not doing much work. You could, if you wanted to, run multiple xulrunners against one Xvfb.<br>The other issues you mentioned are not related to this problem. I think the way to go about solving them is to create a new embedding client that implements nsIPromptService and other UI control interfaces.<br></div>
</div>
<div class='comment'>
<div class='author'>John</div>
<div class='content'>Just following up on the earlier comment around a buffer solution being preferable to an Xvfb-type solution...<br>It appears that there are some significant limitations on how xulrunner can interact with the X display system (Xvfb specifically) when there is no interactive user (i.e. conventional gui I believe) logged in.  For example, a daemon that needs to render can create an Xvfb display and put xulrunner on it, but xulrunner dies because there is something in the X environment it doesn&#39;t like when there is no interactive login.  The identical daemon/application can be started from an interactive login (same user as the daemon) and runs fine.<br>While no X expert on how it may be possible to work around this limitation (and the point is one shouldn&#39;t have to be an X expert in order to use xulrunner to do rendering), this would be a good specific example of the continuing pain that would result from a solution to the render-to-buffer solution that relies on systems other than memory under the control of xulrunner.  There will be continuing issues that require lots of extra development work instead of having a rendering component that &#39;just works&#39; all the time and everywhere.<br>There has been so much good work go into Mozilla and there has been such a long wait for a good solution to the rendering need that it would be a great loss to put a band-aid on it instead of a solid, complete, portable and reliable solution.<br>Thanks for listening!<br>jsinton a t cavelle d o t com<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Okay, so there&#39;s a bug that needs to be fixed with xulrunner and Xvfb. We can do that.<br>&gt; There will be continuing issues that require<br>&gt; lots of extra development work<br>Worse than creating and maintaining an entirely new port? I still don&#39;t think so.<br>&gt; a solid, complete, portable and reliable<br>&gt; solution<br>As I mentioned in the original post, the membuf approach cannot be regarded as a complete solution for most potential users, because it can&#39;t support plugins.<br></div>
</div>

</div>