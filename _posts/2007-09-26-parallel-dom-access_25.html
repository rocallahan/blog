---
layout: "post"
title: "Parallel DOM Access"
date: "2007-09-25 16:19:00 +0000"
categories: "Mozilla"
permalink: "/2007/09/parallel-dom-access_25.html"
---
<div class="columns"><p>Suppose we want to exploit parallelism to load and run an existing Web application faster. How might that be done?<br/><p>Here's a very high level diagram of the data flow inside the browser. I believe it's reasonably accurate for Webkit as well as Gecko.<br/><div style="text-align:center;"><iframe src="/assets/images/BrowserDataFlow.svg" style="width:285px; height:315px; border:0"></iframe></div><br/><p>There are some missing edges in some cases; for example, the style system can affect the DOM via XBL. I'm going to gloss over those for now.<br/><p>Observe that the DOM is really the center of the universe. It's a big blob of mutable state that everything else depends on. Any parallelization of single-page applications is going to have to carefully manage access to the DOM.<br/><p>For performance reasons, changes to the DOM are lazily propagated to the style system, layout and rendering. The goal is to batch changes so that these phases are not reexecuted too often --- they're expensive, even when incremental. DOM updates make method calls to registered listeners. Listeners record which styles might have been affected and post a restyle event (if one hasn't already been queued) to be processed later. Similarly, they set dirty bits in the frame tree and then post a reflow event. On the other side, the parser batches its appends to the DOM as well. It's primarily only script execution that makes many fine-grained, interleaved reads and writes.<br/><p>[There are times when scripts need access to up-to-date style and layout data. In Gecko, at those times we invoke FlushPendingNotifications to force synchronous restyling and layout. Because this is already a significant performance hit, Web developers should already be trying to avoid triggering it (e.g., by accessing DOM <tt>offset*</tt> properties).]<br/><p>I think we could leverage these access patterns to help parallelize browser execution:<br/><ul><br/><li>Parsing can be mostly asynchronous; it should only need to synchronize with the DOM when it's ready to append a bunch of elements.<br/><li>Styling, layout and rendering can take a <em>snapshot</em> of the DOM and use it while the real DOM is being updated by other tasks. It's OK for the display of a page to lag slightly behind; it already does today. The snapshot will be refreshed each time we need to update the window again, or when layout results must be return synchronously to scripts.<br/><li>To run scripts, such as JS event handlers, in parallel, we could use optimistic concurrency via transactions. The idea is that we run a script speculatively against a snapshot of the DOM, recording which parts of the DOM it reads and suppressing its changes to the state of the DOM and other parts of the world. When the script has completed, we synchronize with the real DOM and check whether anything the script depended on has changed. If not, then we can commit the script's global changes. Otherwise, its execution is invalid; we throw out its changes and reexecute it all over again.<br/><li>Some DOM-accessing code cannot be executed speculatively, such as plugins, or Javascript that takes actions that cannot be rolled back, such as sending a message to a server. (At CMU, the canonical example of an irrevocable message was "fire missile!") Therefore at any point in time there can be (at most) one thread accessing the "real DOM" which is not speculative and will never be asked to abort.<br/></ul><br/><p>This model would be particularly useful for Firefox where extensions written in Javascript have access to the DOMs of all browsed pages. We could allow extensions to execute in parallel with client code as long as at least one of them is speculative.<br/><p>None of this is easy to implement. Making real snapshots of the DOM would be prohibitively expensive, so some kind of versioning or copy-on-write scheme is required. Which state constitutes "the DOM" that needs versioning is actually a little nebulous; for example, would we version the state of <tt>&lt;canvas&gt;</tt> elements? How about DOM Storage or the proposed DOM SQL API? However, the good news is that some of this can be done incrementally. For example, we could start with a limited slice of DOM state that is versioned, and decree that speculative script accessing any other state is aborted, and then gradually increase the scope of versioning.<br/><p>There's a lot more to think and talk about in this area.</div><br/><br/>
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>Peter Kasting</div>
<div class='content'>Roughly what percentage of time do the various blocks in your diagram take up today, in Gecko?<br>I&#39;m trying to think what the best-case win for your parallelized scheme is, and I&#39;m wondering whether it&#39;s much of a win.  It seems like the biggest wins here come when one of the following is true:<br>* Parsing takes a long (CPU) time, so we frequently have a significantly updated DOM that we&#39;d like to layout and render, if it didn&#39;t block further parsing.  Does this really happen?  Seems like it wouldn&#39;t be likely.<br>* Script is doing lots of updates to the DOM for a long period of time.  I guess this could be the case if we have a lot of Greasemonkey scripts (or extensions, as you mentioned), but I wonder how applicable it is in general.<br>Even in these cases, the win is mainly that your page appears to refresh slightly more quickly.  It doesn&#39;t seem like in the common case this makes your rendering noticeably faster, or makes script run lots faster (unless you had lots of simultaneous readers of the DOM data... maybe with Gears&#39; multithreaded JS?).  Am I totally missing your point?<br>I feel like a bigger win for Firefox would come from either finding a way to pull UI event handling/updating out onto its own thread/process, or at least making all the other pieces of the browser enforce maximum running times on themselves before giving the message loop another crack at things.  That would take care of one of my biggest annoyances with Firefox, namely the way that large pages which finally finish loading or Flash videos which are doing lots of processing or network access cause the browser&#39;s UI to hang.  If the app was always responsive it would go a long way to making it feel both faster and more stable.<br></div>
</div>
<div class='comment'>
<div class='author'>smaug</div>
<div class='content'>Snapshot DOM (SDOM) is exactly what I&#39;ve been thinking lately, though only to be used by style/layout/rendering (slr). To help that, calls to synchronously flush layout should be reduced. Making sure that FlushPendingNotifications (or whatever in other engines) is used only when really needed might help performance even now, and if slr could be moved to a separate thread, then even more.<br>One thing to think about is event handling. Events are targeted based on layout objects etc. If layout is using SDOM, and DOM has been changed, what should be done? Possibly resynchronize SDOM based on version information in DOM. Hopefully synchronization doesn&#39;t happen too often, like for every mousemove event.<br>Could the slr be split somehow to be run on several threads. Rendering/painting using a snapshot of layout... mem usage would climb if there was many kinds snapshots of the system...<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Peter:<br>&gt; Roughly what percentage of time do the various<br>&gt; blocks in your diagram take up today, in Gecko?<br>Depends entirely on the page, but they&#39;re all significant.<br>&gt; * Parsing takes a long (CPU) time, so we<br>&gt; frequently have a significantly updated DOM<br>&gt; that we&#39;d like to layout and render, if it<br>&gt; didn&#39;t block further parsing. Does this really<br>&gt; happen? Seems like it wouldn&#39;t be likely.<br>Parsing is often a significant amount of CPU time. It would be very nice to be able to overlap it with inline script execution and with incremental layout and rendering.<br>&gt; Script is doing lots of updates to the DOM for<br>&gt; a long period of time. I guess this could be<br>&gt; the case if we have a lot of Greasemonkey<br>&gt; scripts (or extensions, as you mentioned), but<br>&gt; I wonder how applicable it is in general.<br>Script-heavy apps are getting more and more common. And many are already coded with lots of callbacks, handling AJAX responses, user input, periodic timers, animation, etc. These don&#39;t all do &quot;lots of updates&quot; to the DOM, but that&#39;s good...<br>&gt; Even in these cases, the win is mainly that<br>&gt; your page appears to refresh slightly more<br>&gt; quickly. It doesn&#39;t seem like in the common<br>&gt; case this makes your rendering noticeably<br>&gt; faster, or makes script run lots faster (unless<br>&gt; you had lots of simultaneous readers of the DOM<br>&gt; data... maybe with Gears&#39; multithreaded JS?).<br>&gt; Am I totally missing your point?<br>I&#39;m hypothesizing that we can a) improve page load times and b) improve interactive response times.<br>Definitely, one of the first things to be done before stepping down this path would be to test this hypothesis, probably by instrumenting an engine to capture detailed application behaviour and then simulate a parallelization scheme to estimate the benefit.<br>I&#39;m also not suggesting this is the only way to exploit parallelism. This is just one way that might be valuable to us.<br>&gt; I feel like a bigger win for Firefox would come<br>&gt; from either finding a way to pull UI event<br>&gt; handling/updating out onto its own<br>&gt; thread/process, or at least making all the<br>&gt; other pieces of the browser enforce maximum<br>&gt; running times on themselves before giving the<br>&gt; message loop another crack at things.<br>I definitely agree. Your first suggestion is hard for us because of the way XUL, JS and the extension system work (which is also one of our strengths, so I don&#39;t think we should just walk away from it). Supporting parallel DOM access would actually be a good step towards supporting running browser UI concurrently with content script, without breaking the current model.<br>Your second suggestion is also on the money. Two things that we should do post-1.9 are &quot;interruptible reflow&quot; (detect pending events, stop reflow, and then restart it after handling the events), and putting (some) plugins in their own process(es). But these are separate issues really, and much easier to solve.<br>smaug:<br>&gt; Events are targeted based on layout objects<br>&gt; etc. If layout is using SDOM, and DOM has been<br>&gt; changed, what should be done?<br>We can actually tell whether an event is targeting a dirty frame or not. I think in common cases we could get away without flushing layout every time the mouse moves.<br>&gt; Could the slr be split somehow to be run on<br>&gt; several threads.<br>Yep but they probably all want to use the same snapshot.<br>&gt; mem usage would climb if there was many kinds<br>&gt; snapshots of the system...<br>Yes. It&#39;s imperative that you only store the differences between the snapshots, not entire copies of the DOM.<br></div>
</div>
<div class='comment'>
<div class='author'>Axel Hecht</div>
<div class='content'>I would expect that the web2.0 eye candy stuff with animated pull up, down, through, whatever would be the biggest challenge. And stuff like finkle&#39;s bubbles demo.<br>All of them create content dynamically, partly even lots of it, and then repeatedly modify the DOM to change the style and layout, and look like a worst-case scenario here to me.<br>Being able to animate the style natively could give an perf improvement path to webauthors in this case, too.<br></div>
</div>
<div class='comment'>
<div class='author'>Dimitri Glazkov</div>
<div class='content'>Robert, I think you&#39;re going in the right direction. Here are some more thoughts on DOM snapshots from a while back:<br>http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2005-July/004304.html<br></div>
</div>
<div class='comment'>
<div class='author'>shaver</div>
<div class='content'>Do you envision something like RCU as a way to snapshot the DOM? (http://www.rdrop.com/users/paulmck/RCU/whatisRCU.html)<br>At one point I looked at using RCU to make access to the XPCOM component registry lock-free in the dominant cases, but it didn&#39;t make it to the top of the stack.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>I don&#39;t think RCU is quite what is needed here.<br></div>
</div>
<div class='comment'>
<div class='author'>RichB</div>
<div class='content'>&quot;Snapshots&quot; and &quot;Copy on write&quot; sound like you&#39;re thinking about implementing the DOM as a &quot;Purely Functional Data Structure&quot;?<br></div>
</div>
<div class='comment'>
<div class='author'>Jon Smirl</div>
<div class='content'>A few years I tried implementing a thread aware browser and it was a complete disaster. It is very difficult to get the locking right and adding the locks everywhere slows everything down. I concluded that trying to split a page up using fine grained parallelism wasn&#39;t a good strategy. We did end up implementing image downloads in threads.<br>There are other schemes for increasing parallelism in a browser. For example each page could be in it&#39;s own process with a process managing the browser frame and tabs. Like MS OLE. This keeps pages from messing with each other&#39;s performance.<br>Schemes using shared memory can work too. Things are split into different processes to achieve parallelism and then communicate via asynchronous messaging. Access to the data structures is serialized but things like parsing or image decoding happen in the parallel processes and send messages to update the DOM.<br>Lately we have been experimenting in git with fine grained parallelism. So far it is always slower except when we can go parallel for something that takes several seconds to complete.<br></div>
</div>
<div class='comment'>
<div class='author'>Matt</div>
<div class='content'>What about using transparent wrappers for DOM method return values (and out-of-scope JS values) to defer execution of results until necessary?<br>The Javascript value returned from DOM methods (and potentially passed to them) represents an opaque token.  When the script reaches a point where it needs to get the real value - an if statement, passing the value to a single-threaded object or combining it with a value independent of the shared state, it ends up being a synchronization point where the code would wait for the correct value.<br>This could limit the amount of rollback for functions.  The opaque tokens could even be passed back into the DOM, where the results would be evaluated when available.<br>I think the PyPy developers worked on something like this.<br></div>
</div>
<div class='comment'>
<div class='author'>Myk Melez</div>
<div class='content'>On the TV show &quot;24&quot; last year, the US government fired a missile in a game of brinksmanship with another country but eventually redirected it into an ocean.  I&#39;m not sure how realistic it is, but perhaps missile launches aren&#39;t as irrevocable as they used to be.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>You can abort the flight but you can&#39;t get the missile back into its launch tube :-)<br></div>
</div>
<div class='comment'>
<div class='author'>Jeremy Lea</div>
<div class='content'>The language you are using here makes me think of file systems...  If you view the DOM as a file system with elements/nodes as directories and attributes as files (with content being attributes on anonymous nodes), exactly like the DOM inspector does.  Documents become &#39;volumes&#39; and are &#39;mounted&#39; at various points.<br>Maybe the right thing to do is to think like this.  Abandon C++ object thinking for a while and build the DOM as an in memory file system, using a special memory allocator.  Then layer the objects back onto the &#39;files&#39; as an abstraction.<br>In this case the active set of C++ objects could be a lot smaller than the actual set of DOM nodes, because you could only have active C++ objects for the nodes currently being accessed by methods.<br>And if you had some sort of &#39;mmap&#39; support you could make the construction of C++ nodes be very memory conservative for nodes with lots of data (images, text).<br>This would allow you to leverage a lot of work on parallel access to file systems, including locking, snapshots, copy-on-write, transactions, caching, garbage collection, etc.<br>I&#39;m not sure that the style system is at the right level in that picture though?  The style information is layered on top of the DOM, like a unionfs in some ways...  I guess this is what your dashed arrows are trying to say.  A unionfs would also allow you to have a layer on top of a parsed HTML page which represented the active version of the page, where all the JavaScript changes would go, and which would be layered on the original DOM to provide the back/forward cache.<br>The unionfs idea could be used to do the transactions.  Snapshot the DOM, &#39;mount&#39; a new unionfs layer on the snapshot, then try to fold it back in after completion.<br>You could also use this &#39;memory file system&#39; and the real mmap to cache the DOM on disk rather than raw pages.  It would give you a good speedup, since you could avoid parsing the page.<br>One would have to do some careful thinking about what information you would want in the file system.  Do creation time and ownership really have a real purpose in the DOM?  The DOM also requires order preserving between directory entries.  You would also want to have very small blocks, and forget about disk platters etc.  But on the plus side, there is a lot of free code, and you can sift through it looking for good ideas.  You could probably even prototype the system on current memory file system like tmpfs, using it to develop the DOM C++ code, and seeing what your access patterns looked like, and then using that profiling info to build your special file system.<br>Maybe at a lower level, the problem here is that the browser is a seen as an application, and not the kernel of a new type of OS.<br>OTOH, I probably don&#39;t know what I&#39;m talking about.<br>-Jeremy<br></div>
</div>
<div class='comment'>
<div class='author'>deepwalkercr__(4t)__gmale</div>
<div class='content'>Did you ever see the parrallel access all atomic functions hashtable on Google tech vids<br>Very light on processor time, n level versioning.<br>Could be viewed as a file system, but very simple and very very fast<br></div>
</div>

</div>