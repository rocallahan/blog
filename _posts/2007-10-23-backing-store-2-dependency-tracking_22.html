---
layout: "post"
title: "Backing Store #2: Dependency Tracking"
date: "2007-10-22 21:23:00 +0000"
categories: "Mozilla"
permalink: "/2007/10/backing-store-2-dependency-tracking_22.html"
---
<div class="columns"><p>I had another lovely Labour Day weekend away with my family at the beach. Naturally my thoughts turned to browser engines and again I'll take the liberty of recording them here...<br/><p>One of the reasons Web layout is difficult is that you have to handle incremental layout efficiently. That means whenever your layout code accesses style data (e.g., <tt>GetStylePosition()->GetOffsets()</tt>), you need to think about what happens if 'left' changes. How do you guarantee that the layout will be updated?<br/><p>In Gecko, this is mostly handled using "style change hints". When style changes, we compare the old and new styles and produce a set of bits summarizing what needs to be changed. One bit indicates that the frame (i.e. layout object) associated with the element needs to be reflowed. When a style change finds that bit set, we mark the associated frame "dirty" and eventually a reflow will happen for that frame.<br/><p>The problem with this approach (and other similar approaches that we use for incremental layout and rendering) is that it decouples the code that <em>consumes</em> style data from the code that causes <em>updates</em> when that style data changes. This is fragile. For example, if you add new code that reads style data during layout, you'd better make sure that the style change hints are set correctly for when that style changes (and this code will be in an entirely different place), otherwise you will have subtle incremental layout bugs. It's also inflexible because it forces a strict pattern of dependencies; the layout of a frame can depend only on the style of its own element; if you want to look at the style of other elements, that's just not supported and you'll have to hack around it with more fragile code.<br/><p>It would be helpful to have a technique that let us write only on the code that consumes style data, automatically ensuring that sufficient updates are issued when that data changes. Actually we would want this technique to extend beyond style data to other data sources too.<br/><p>(What I'm asking for is really a form of <a href="http://en.wikipedia.org/wiki/Reactive_programming">reactive programming</a>. I unfortunately don't know much about research in that area, except that it seems to be mostly conducted in specialized domains with exotic languages such as Haskell and Esterel, so probably not of much use to us.)<br/><p>Of course the hard part is performance; we'd want a solution that's as least as efficient as what we currently do. For example, a solution that creates a pile of explicit one-way constraints, one per dependence, would be hopeless.<br/><p>So here's one idea. Define an <tt>Updater</tt> class representing a no-arg function that will cause a computation (say layout of an element) to be re-executed in response to a change in underlying data. Make style data getters take an Updater parameter:<br/><pre><br/>class Updater {<br/>virtual void Update() = 0;<br/>};<br/>class nsIFrame {<br/>...<br/>nsMargin GetStylePositionOffsets(Updater* updater);<br/>...<br/>};</pre><br/>The contract is that when the offsets change, the updater will be invoked. I've moved style data access from a style object directly to the frame, because changes to the frame's style need to be tracked, not changes to the style context itself (it's basically immutable in Gecko). GetStylePositionOffsets will record a set of updaters that depend on the offsets of this frame. The caller will do something like:<br/><pre>class ReflowUpdater {<br/>ReflowUpdater(nsIFrame* frame) : mFrame(frame) {}<br/>void Update() { mFrame-&gt;PresShell()-&gt;FrameNeedsReflow(mFrame); }<br/>nsIFrame* Frame();<br/>nsIFrame* frame;<br/>};<br/>...<br/>nsBlockFrame::Reflow(...) {<br/>ReflowUpdater* updater = new ReflowUpdater(this);<br/>...<br/>nsMargin offsets = GetStylePositionOffsets(updater);<br/>...<br/>}</pre><br/>Now it's impossible, or at least hard, to depend on style data without the dependency being recorded.<br/><p>This would of course be appallingly inefficient, so how can we make it efficient? We can adapt Gecko's current approach. Let's make a rule that changing certain style properties, such as the offsets, will always force the frame to be reflowed. In that case we don't need to record the dynamic dependency. If we're a little bit clever we can avoid almost all run-time overhead. First let's index all the style properties with integers and then have a table that tells us if we need to reflow when that property changes:<br/><pre>enum nsStylePropID { ..., POSITION_OFFSETS, ... };<br/>const PRPackedBool styleChangeForcesReflow[];</pre><br/>We delay realization of dynamic Updater objects until they're really necessary:<br/><pre>class Updater {<br/>class Realized {<br/>virtual void Updater() = 0;<br/>};<br/>virtual Realized* Realize() = 0;<br/>};</pre><br/>Then we refactor the style getters:<br/><pre>class nsIFrame {<br/>...<br/>template &lt;class U&gt; nsMargin GetStylePositionOffsets(const U& updater) {<br/>TrackDependency(updater, POSITION_OFFSETS);<br/>return GetStylePosition()-&gt;GetOffsets();<br/>}<br/>void TrackDependency(const Updater& updater, nsStylePropID style) {<br/>... add updater-&gt;Realize() to dynamic dependency storage ...<br/>}<br/>void TrackDependency(const ReflowUpdater& updater, nsStylePropID style) {<br/>if (styleChangeForcesReflow[style] && updater-&gt;Frame() == this)<br/>return;<br/>TrackDependency(static_cast&lt;const Updater&&gt;(updater), style);<br/>}<br/>...<br/>};</pre><br/>Assuming the compiler can constant-fold the load of styleChangeForcesReflow[style], this becomes very low overhead. When properties are accessed in a scope where the compiler knows updater-&gt;Frame() == this, there is no overhead.<br/><p>So what's gained? It's now much harder to screw up, and we support more complex dependencies (such as dynamically conditional dependencies, and dependence of one frame on another's style) along with static dependencies in a uniform API. The hard-coded dependencies are now just an optimization that we can easily meter and tune. Similar tricks can be used to track dependencies of painting and other activities.)<br/><p>Other things you'd want to do when implementing this: support revocation of outstanding ReflowUpdater::Realized objects when a frame is actually reflowed; have the style change processing actually use the same styleChangeForcesReflow array to decide whether to reflow frames.<br/><p>There is extra complexity in some places, so it's not a no-brainer. Just something to think about.</div><br/><br/>
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>monk.e.boy</div>
<div class='content'>Good lord, I&#39;m glad someone bright is doing this. Sounds like, way complex, man ;-)<br></div>
</div>

</div>