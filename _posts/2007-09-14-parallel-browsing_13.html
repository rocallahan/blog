---
layout: "post"
title: "Parallel Browsing"
date: "2007-09-14 00:07:00 +0000"
categories: "Mozilla"
permalink: "/2007/09/parallel-browsing_13.html"
---
<div class="columns"><p>My mate <a href="http://www.cs.berkeley.edu/~bodik/">Ras Bodik</a> has just produced a blog covering his new <a href="http://parallelbrowser.blogspot.com/2007/09/hello-world.html">"parallel browsing"</a> project. It's a great read, especially <a href="http://cs.berkeley.edu/%7Ecgjones/papers/intel-browser-2007.08.pdf">the slides</a> (which don't display correctly in Mac's Preview, but do in Acrobat Reader). There's some great observations and ideas in there, plus some neat preliminary results about parallel lexing. The bottom line is that future generations of devices will need a web browser that can efficiently utilize tens to hundreds of CPU cores.<br/><p>This is extremely challenging for many reasons:<br/><ul><br/><li>Existing browser engines are written in C++, which offers only a classic multithreaded parallel programming model: threads, shared memory, locks, semaphores, etc, plus hand-rolled lock-free primitives. These tools are very difficult to use and mostly don't scale very well. There is no direct support for optimistic concurrency.<br/><li><a href="http://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl's Law</a> means that cherry-picking a few optimization opportunities won't be enough to scale to a large number of cores. We will have to work parallelism through every stage of the browser's processing.<br/><li>It's not at all clear how much of what the browser does can be parallelised. Ras' group's work on parallel lexing is a small first step. Can one write an HTML5 parser in parallel, and if so, how? How about JS/DOM manipulation? Layout? Rendering? The programming model we expose to Web developers is inherently single-threaded and I don't think we should change that.<br/><li>Massive changes to browser code (including rewriting it in a different language) are very risky, and can damage compatibility credibility.<br/><li>Our debugging and profiling tools are already crappy for mostly single-threaded code. Debugging and profiling parallel code will be much harder.<br/><li>Browsers rely on a lot of platform library code. That code also needs to be refitted for scalable parallelism or it will become a bottleneck.<br/></ul><br/><p>Bottom line: writing a good browser engine is already really hard. Requiring scalable parallelism adds a whole new dimension of engineering difficulty, and poses a bunch of research-level questions which we don't yet have answers for.<br/><p>I plan to blog about my thoughts on these issues and how they might be solved. But my impression is that it will be very difficult for existing browsers to move into multicore territory, due to language choices, the difficulty of refitting existing code, compatibility with existing code consumers, a desire to not compromise single-core performance, and the enormous risk of a large investment in a long development cycle with no guarantee of success.<br/><p>I believe there is a huge disruption opportunity here: an effort focused on building a new parallel browser, with no interest in single-core performance, which can rethink all engineering choices, could start by filling a niche and eventually dominate. It could also flame out spectacularly! It would be great territory for a startup, if VCs weren't obsessed with creating the next great social networking site. It's good territory for research --- Ras is on the money. I do hope that if such a disruptive effort wins, the code is open source. I'm not sure what can be done to help ensure that.</div><br/><br/>
<div class='comments'><h2>Comments</h2>
<div class='comment'>
<div class='author'>Jeremy Lea</div>
<div class='content'>I don&#39;t know that the real opportunity here is in a parallel browser, as such, although it is such a vital piece of software that it is important.  The real opportunity lies with the tools that one would need to build in order to build such a browser.  Just looking over your post, most of the problems you mention are not problems with a parallel browser - they are that the tools don&#39;t help you - they get in your way...<br>I&#39;m not a computer scientist, but I do spend a lot of time writing performance critical code, and have done a little work on MPI/OpenMPI, and I&#39;ve been following the discussion around SMP support in the FreeBSD kernel...<br>The main tool needed is a good compiler/IDE: one that can take code (especially existing code in C++) and turn it into a syntax tree that can be stored rather than the raw language (with enough &#39;sugar&#39; that a language can be reconstructed - with the preferred formatting of the user).  It should also store the optimization results (including auto-parallelizing the code), including the &#39;optimized&#39; code, and places where it failed to optimize for some reason.  Then it could present you with a GUI IDE where you could look at the code, and then switch over to an &#39;optimized&#39; view, to see what it did, or to show you why it could not optimize code (for example not being able to determine that pointers/references are non-overlapping, so not being able to do things in  parallel, or places where it has to issue cache flushes).<br>It also needs a profiler, or something to help you  track down the slow parts of your code that are on the critical path and point them out to you, so you can spend time tweaking them.  The problem here is that the performance is very dependent on the CPU, memory, kernel, threads, malloc, etc, etc.  So the system really needs be fairly integrated with the entire environment, so that it knows that issuing an atomic write will stall all the CPUs and flush their caches (for example), and that the performance penalty from that should not be attached to the code running on the other CPUs but to the code which did the write - this would mean needing to do some sort of &#39;instruction cost&#39; profiling rather than just time based.  Profiling in a VM or a chronicle type profiler might be good for this.<br>These wont help you with high level parallelism, but then not much other than being super smart will.  But these would help you to get that working - and show you where what looks like a simple instruction actually will stall the entire application, or where you have lots of lock contention.<br>I think that there&#39;s a bit more time before this all happens than Intel would like us to believe - simply because the tools are not there.  Kernels struggle to scale past 8 cores, unless they&#39;re doing something special.  Most of the real world performance from multi-cores still comes from &#39;start one process per processor&#39; designs, and that&#39;s not much use on the desktop.  Lots of desktop time is spent in the GPU, and GPU manufactures are not showing any interest in helping speed 2D rendering (remember when ATI put crystal fonts - an accelerate font renderer - on their cards).  Basically, in the desktop market people are going to go into Walmart, play with the mouse a bit, open up some windows, and see that the 2-core machine is the same speed as the 8-core machine, and cheaper.  People who care about performance (gamers and rocket scientists - in that order ;-) already test the heck out of their systems, and can see that 4-core machines are bottle necking in all sorts of other places.<br>Regards,<br>-Jeremy<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Thread creation overhead is really not an issue at all. It is really simple to use thread pools to make thread creation cost a non-issue.<br>Reducing per-thread stack usage is hard, and it would require modifications to the C++ compiler to make get heap-allocated stack records or whatever Erlang does, which would hurt performance in some ways. But that&#39;s not the hard part of parallelism either.<br></div>
</div>
<div class='comment'>
<div class='author'>Brendan Eich</div>
<div class='content'>See https://bugzilla.mozilla.org/show_bug.cgi?id=multicore where I write similar words to roc&#39;s here: responsive UI does *not* require multiple threads or multiple core. We should fix responsiveness bugs in Firefox. We should not reach for conventional shared-memory threads to solve problems they do not address, when threads have big safety and scaling problems of their own.<br>/be<br></div>
</div>
<div class='comment'>
<div class='author'>Markus S.</div>
<div class='content'>&gt; I think that basically people can only pay attention to one page at a time, so parallelizing across pages is not very interesting.<br>I do think it is interesting. Most of the pages I visit will load in a background tab, due to the fact that I mostly middle-click on links. Thus, it happens to me several times a day that the active tab freezes because some page in the background does some heavy JavaScript computation.<br>Were tabs rendered concurrently, I could still interact with the active tab (i.e. scroll, click links) without having to wait for pages I can&#39;t even see yet.<br>On another note: If Erlang can create extremely lightweight &quot;threads&quot; efficiently - why can&#39;t be something written with C++ that is able to do the same? (assuming these threads were without shared state, side-effects, etc.)<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Firefox 3 won&#39;t use Adobe&#39;s engine. Some future version of Firefox will. But that doesn&#39;t mean Javascript code will automatically just get faster as we add more cores. We could expose some kind of Javascript concurrency to Web developers, but that seems perilous and won&#39;t help with the masses of existing code.<br></div>
</div>
<div class='comment'>
<div class='author'>Markus S.</div>
<div class='content'>&gt; And it&#39;s a bug that can be fixed without requiring multiple cores or even multiple threads.<br>That&#39;s really nice to hear.<br>&gt; It&#39;s frustrating that so many people seem to think that Erlang has solved all the problems of concurrency and parallelism.<br>That&#39;s not what I said. Of course Erlang hasn&#39;t solved it all. However, large thread creation overhead is certainly part of the problem when it comes to concurrent programming. What I&#39;d like to know is: Why can&#39;t C++ do what Erlang can? Does it need some kind of low-level access that can only be provided by the compiler?<br>Pardon my ignorance.<br>&gt; I guess I&#39;ll have to write a whole blog entry just to debunk this myth.<br>I&#39;d love to read that one.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Stackless Python doesn&#39;t have anything to do with parallelism.<br></div>
</div>
<div class='comment'>
<div class='author'>Matt</div>
<div class='content'>I&#39;m not sure if you have seen this before or not.  Here is Brendan Eich&#39;s thoughts on concurrency in JS.  The comments go into more details, but he seemed to be leaning towards building a message passing system into JS3.<br>http://weblogs.mozillazine.org/roadmap/archives/2007/02/<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Diego: that snapshot idea is a good one, it&#39;s not the same as RCU however. I had been thinking about lightweight snapshots as one of the things that would be needed to parallelize browsers.<br>Sjoerd: just saying &quot;we&#39;ll assign one thread to this, and one thread to that&quot; does not solve any of the hard problems. The hard problems are about how the interactions between concurrently executing threads are managed.<br>funTomas, Markus: if a background application is consuming tons of CPU time and interfering with my use of a foreground application, then I consider that a bug in the background application.<br>It&#39;s really a bug in Firefox that the load and layout of a large background page can block interaction with the foreground page. And it&#39;s a bug that can be fixed without requiring multiple cores or even multiple threads.<br>Markus: the problem is much much bigger than &quot;creating lightweight threads efficiently&quot;. It&#39;s frustrating that so many people seem to think that Erlang has solved all the problems of concurrency and parallelism. It most certainly has not --- do you think all the researchers working in this area are just stupid? I guess I&#39;ll have to write a whole blog entry just to debunk this myth.<br></div>
</div>
<div class='comment'>
<div class='author'>funTomas</div>
<div class='content'>&quot;I think that basically people can only pay attention to one page at a time, so parallelizing across pages is not very interesting.&quot;<br>Roc, I dare to disagree, since some apps eat all CPU time even when in the background. That&#39;s exactly the user case the separately processed threads would benefit from at most.<br></div>
</div>
<div class='comment'>
<div class='author'>Nicholas</div>
<div class='content'>My main beef with current browsers is that they lack a super-mega-fast-quick JS engine. I think FireFox 3 is supposed to use Adobe&#39;s engine, but I don&#39;t know if it&#39;s multithreaded, etc.<br></div>
</div>
<div class='comment'>
<div class='author'>Peter Kasting</div>
<div class='content'>Tamarin (Adobe&#39;s engine) isn&#39;t all that great shakes anyway.  It&#39;s not like it&#39;s an order of magnitude faster than SpiderMonkey -- even in the best case it&#39;s something like a factor of 2 (or maybe 3?) better, and for the JS commonly found on the web (not compiled ActionScript, or whatever) my impression was that it is basically a wash at best.  I could be wrong in all this, but so far all the outside-looking-in watching I&#39;ve done of the Tamarin announcements has left me less than impressed.<br>For that matter, the JS engine alone isn&#39;t necessarily as important as the DOM bindings.  I think SpiderMonkey is the fastest JS engine when benchmarked standalone, but in several cases on the web Safari and Opera get wins from lower-overhead DOM bindings.  Maybe this would change, though, if people had a &quot;super-mega-fast-quick&quot; engine, in that it&#39;d become more performant to write calculation-heavy JS code if it could save some DOM manipulation?  Not sure how that would work though.<br>Changing topics... roc, in the abstract, do you think a bigger multicore win would come from somehow parallelizing each chunk of the rendering engine (a parallelized parser, layout, rendering, etc.), or would it be better to basically keep a sort of &quot;single core engine&quot; and simply have many instances of that (say, one per page, or per group of pages, or something)?  I&#39;m aware that both methods cause thorny problems for scripts, are hard (if not impossible) to retrofit into Gecko, etc.<br>My take on the question is that it probably depends on the usage model.  If most people use one or few tabs/windows, then the first route, if possible, would be better, because a single visible page is no better in the second route than today&#39;s engines.  If people are using lots of tabs, the second route might be easier to write; I&#39;m not sure how I would parallelize some of the pieces of the engine, and if there are still significant bottlenecks, the first route is not going to be much of a win.<br>I find the question interesting from my years working on compilers... many multicore designs were touted as being fast when developers could rely on the toolchain to &quot;do the hard work&quot;, and I found it amusing that we compiler authors didn&#39;t know how to solve the parallelization problems better than anyone else.<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>Matt: I&#39;ve read that, yes.<br>Peter: I think Tamarin needs work to cope better with untyped Javascript that you find on the Web, and it&#39;s premature to conclude that large speedups cannot be obtained. But anyway, that is a bit off topic...<br>Your question about parallelizing within pages vs across pages is interesting, and I&#39;m planning to write about that on my blog. I think that basically people can only pay attention to one page at a time, so parallelizing across pages is not very interesting.<br>I snickered when people put their faith in compilers to fix Itanium&#39;s performance problems, and I don&#39;t intend to commit the same mistake myself. But I think there are improvements in programming languages that could really help without requiring extraordinary effort in the compiler.<br></div>
</div>
<div class='comment'>
<div class='author'>Rene L.</div>
<div class='content'>If I hear about a high amount of parallel tasks, Stackless Python comes to my mind:<br>http://www.stackless.com/<br>There even is a MMOG already with &quot;hundreds of thousands&quot; of tasklets (EVE Online).<br>http://www.tentonhammer.com/node/10044<br>And there are of course many more advantages of using a high-level language... ;)<br></div>
</div>
<div class='comment'>
<div class='author'>Robert O'Callahan</div>
<div class='content'>monk.e.boy: JS is not fast enough, people are complaining about it already. And there are applications that are not being built because JS is not fast enough to run them. And we are talking about moving to a world where each core is significantly slower than today&#39;s desktop/laptop CPUs, so if we&#39;re not careful things will actually get *worse*. Benchmarked JS on an iPhone lately? Read Ras&#39; slides.<br>&quot;why aren&#39;t we doing anything about this?&quot; We are. We&#39;re working hard on SVG, cairo, browser-based video and related issues.<br>Silverlight is a concern, definitely, but there&#39;s no need to panic just yet. It will be long time before Silverlight gets enough client penetration for people to rely on it. Lots of people are learning C#, but lots are also learning Java and Javascript, and dynamic languages (like JS, not C#) are rising in popularity.<br>Rest assured, no-one out-paranoids me!<br></div>
</div>
<div class='comment'>
<div class='author'>Markus S.</div>
<div class='content'>Thank you for clearing that up. It seems like I have to do some reading on this.<br></div>
</div>
<div class='comment'>
<div class='author'>monk.e.boy</div>
<div class='content'>But JS is fast enough really - or are we talking JS + SVG + Animation?<br>Why fiddle with something that works OK? Where are these real world applications where the JS engine is the bottleneck?<br>Lets focus on the SVG animation/timeline code. That is the new web - HTML is old skool. Silverlight + C# + millions of developers and students and high school kids programming C# and silverlight IDE = death of open standards.<br>There is a Flash movie on every page of the internet at the moment - why aren&#39;t we doing anything about this?<br>monk.e.boy<br></div>
</div>
<div class='comment'>
<div class='author'>Sjoerd Visscher</div>
<div class='content'>What about simply assigning one processor for each tab, and one for the UI. Even with 2 processors it would be great if the UI would get its own processor, so a number crunching page wouldn&#39;t lock the UI.<br></div>
</div>
<div class='comment'>
<div class='author'>Diego</div>
<div class='content'>The Linux RCU-style locking scheme applied to desktop could be interesting (like they apparantly do in http://osnews.com/comment.php?news_id=18589)<br></div>
</div>

</div>